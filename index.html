<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="愿你出走半生，归来依旧少年">
<meta property="og:type" content="website">
<meta property="og:title" content="NobiGo&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="NobiGo&#39;s blog">
<meta property="og:description" content="愿你出走半生，归来依旧少年">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NobiGo&#39;s blog">
<meta name="twitter:description" content="愿你出走半生，归来依旧少年">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>NobiGo's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">NobiGo's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/28/Spring概述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/28/Spring概述/" itemprop="url">Spring概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-28T13:31:10+08:00">
                2017-10-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li>Spring是分层的Java SE／EE应用一站式的轻量级开源框架，以IOC（控制反转）和AOP（切面编程）为内核，提供了展现层Spring MVC／持久层Spring JDBC以及业务层事务管理等一站式的企业级应用技术。</li>
<li>理念：好的设计优于具体实现，代码应易于测试</li>
<li>Spring好处：</li>
</ol>
<ul>
<li>方便节藕，简化开发。（控制反转IOC）</li>
<li>AOP编程的支持</li>
<li>声明式事务的支持</li>
<li>方便程序的测试</li>
<li>方便集成各种优秀的框架</li>
<li>降低Java API的难度</li>
</ul>
<ol>
<li>Spring框架结构</li>
</ol>
<p><img src="Spring框架结构.jpg" alt="Spring框架结构"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/13/《虚拟化与云计算》读书笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/13/《虚拟化与云计算》读书笔记/" itemprop="url">《虚拟化与云计算》读书笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-13T16:44:28+08:00">
                2017-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/读书笔记/" itemprop="url" rel="index">
                    <span itemprop="name">读书笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><ul>
<li>云计算</li>
</ul>
<p>将各种IT资源（计算资源、存储资源、软件开发、系统测试等）以服务的形式通过互联网交付给用户。</p>
<ul>
<li>虚拟化</li>
</ul>
<p>实现了IT资源的逻辑抽象和统一表示，在大规模数据中心管理和解决方案交付方面发挥着巨大的作用，是支撑云计算的技术基石。</p>
<h1 id="1-数据中心"><a href="#1-数据中心" class="headerlink" title="1. 数据中心"></a>1. 数据中心</h1><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>当你在银行办理业务时，整个交易的流程都在银行的数据中心完成。</li>
<li>当你在互联网上冲浪搜索信息时，请求都悲哀搜索引擎的数据中心接收、处理和返回。</li>
</ol>
<h2 id="类比"><a href="#类比" class="headerlink" title="类比"></a>类比</h2><p>信息是血液，网络是血管，那么数据中心就是最关键的心脏，是信息世界的核心所在。</p>
<h2 id="1-1-数据中心概述"><a href="#1-1-数据中心概述" class="headerlink" title="1.1 数据中心概述"></a>1.1 数据中心概述</h2><h3 id="总的概述"><a href="#总的概述" class="headerlink" title="总的概述"></a>总的概述</h3><p>数据中心是信息系统的中心，通过网络向企业或公众提供信息服务。</p>
<h3 id="逻辑定义"><a href="#逻辑定义" class="headerlink" title="逻辑定义"></a>逻辑定义</h3><ul>
<li>硬件：数据中心的基础设施</li>
<li>软件：数据中心所安装的程序和提供的服务。</li>
</ul>
<p><img src="/images/数据中心逻辑示意图.PNG" alt="image"></p>
<h2 id="1-2-数据中心的设计和构建"><a href="#1-2-数据中心的设计和构建" class="headerlink" title="1.2 数据中心的设计和构建"></a>1.2 数据中心的设计和构建</h2><h3 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h3><ul>
<li>核心理念：简单、灵活、可扩展、模块化</li>
</ul>
<h3 id="建筑的设计和构建"><a href="#建筑的设计和构建" class="headerlink" title="建筑的设计和构建"></a>建筑的设计和构建</h3><ul>
<li>方式：租用机房、构建新的建筑作为数据中心</li>
</ul>
<ol>
<li>选址（通信、电力、地理位置）</li>
<li>建筑要求（规模、布局、高度、室内布局）</li>
</ol>
<h3 id="基础设施的设计和构建"><a href="#基础设施的设计和构建" class="headerlink" title="基础设施的设计和构建"></a>基础设施的设计和构建</h3><ul>
<li>网络（保证了服务器以及存储的互连和访问）</li>
<li>电力（数据中心运行的动力）</li>
<li>环境控制（合适的温度、湿度等环境）</li>
</ul>
<p><img src="/images/数据中心基础设施的设计和构建.PNG" alt="image"></p>
<p><img src="/images/数据中心风冷示意图.PNG" alt="image"></p>
<h3 id="数据中心上线"><a href="#数据中心上线" class="headerlink" title="数据中心上线"></a>数据中心上线</h3><ol>
<li>选择服务器（塔式服务器、机架式服务器、刀片服务器）</li>
</ol>
<ul>
<li><strong>塔式服务器</strong>：（和个人计算机的主机差不多）</li>
<li>优：接口和插槽比个人计算机多，成本低</li>
<li>缺：扩展性有限、占用空间较大</li>
</ul>
<p><img src="/images/塔式服务器.PNG" alt="image"></p>
<ul>
<li><strong>机架式服务器</strong>：（配合机柜使用的服务器）</li>
<li>优：占用空间较小、管理方便</li>
<li>缺：制冷要求高</li>
</ul>
<p><img src="/images/机架式服务器.PNG" alt="image"></p>
<ul>
<li><strong>刀片服务器</strong>：（在机箱上插装多个卡式的服务器单元）</li>
<li>优：支持热插拔、减少成本、节省空间</li>
</ul>
<p><img src="/images/刀片服务器.PNG" alt="image"></p>
<ol>
<li>选择软件</li>
</ol>
<ul>
<li>操作系统</li>
<li>数据中心管理监控软件</li>
<li>业务相关软件</li>
</ul>
<ol>
<li><p>机器上架</p>
</li>
<li><p>软件部署</p>
</li>
<li><p>测试</p>
</li>
</ol>
<h2 id="1-3-数据中心的管理和维护"><a href="#1-3-数据中心的管理和维护" class="headerlink" title="1.3 数据中心的管理和维护"></a>1.3 数据中心的管理和维护</h2><h3 id="硬件的管理和维护"><a href="#硬件的管理和维护" class="headerlink" title="硬件的管理和维护"></a>硬件的管理和维护</h3><h3 id="软件的管理和维护"><a href="#软件的管理和维护" class="headerlink" title="软件的管理和维护"></a>软件的管理和维护</h3><h3 id="数据的管理和维护（数据备份和恢复、数据整合、数据存档和数据挖掘等）"><a href="#数据的管理和维护（数据备份和恢复、数据整合、数据存档和数据挖掘等）" class="headerlink" title="数据的管理和维护（数据备份和恢复、数据整合、数据存档和数据挖掘等）"></a>数据的管理和维护（数据备份和恢复、数据整合、数据存档和数据挖掘等）</h3><h3 id="资源管理（负载均衡）"><a href="#资源管理（负载均衡）" class="headerlink" title="资源管理（负载均衡）"></a>资源管理（负载均衡）</h3><h3 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h3><h2 id="1-4-新一代的数据中心需求"><a href="#1-4-新一代的数据中心需求" class="headerlink" title="1.4 新一代的数据中心需求"></a>1.4 新一代的数据中心需求</h2><h3 id="合理规划（业务的动态性和不确定性会给数据中心的准确规划带来挑战）"><a href="#合理规划（业务的动态性和不确定性会给数据中心的准确规划带来挑战）" class="headerlink" title="合理规划（业务的动态性和不确定性会给数据中心的准确规划带来挑战）"></a>合理规划（业务的动态性和不确定性会给数据中心的准确规划带来挑战）</h3><h3 id="流程化"><a href="#流程化" class="headerlink" title="流程化"></a>流程化</h3><h3 id="可管理性（一个系统能够满足管理需求的能力以及管理该体统的便利程度）"><a href="#可管理性（一个系统能够满足管理需求的能力以及管理该体统的便利程度）" class="headerlink" title="可管理性（一个系统能够满足管理需求的能力以及管理该体统的便利程度）"></a>可管理性（一个系统能够满足管理需求的能力以及管理该体统的便利程度）</h3><ul>
<li>完备性</li>
<li>远程管理</li>
<li>集成控制台</li>
<li>快速响应</li>
<li>可追踪性</li>
<li>方便性</li>
<li>自动化</li>
</ul>
<h3 id="可伸缩性（适应负载变化的能力）"><a href="#可伸缩性（适应负载变化的能力）" class="headerlink" title="可伸缩性（适应负载变化的能力）"></a>可伸缩性（适应负载变化的能力）</h3><h3 id="可靠性（系统执行器功能的能力）"><a href="#可靠性（系统执行器功能的能力）" class="headerlink" title="可靠性（系统执行器功能的能力）"></a>可靠性（系统执行器功能的能力）</h3><h3 id="降低成本"><a href="#降低成本" class="headerlink" title="降低成本"></a>降低成本</h3><h3 id="节能环保"><a href="#节能环保" class="headerlink" title="节能环保"></a>节能环保</h3><h1 id="2-虚拟化技术概述"><a href="#2-虚拟化技术概述" class="headerlink" title="2. 虚拟化技术概述"></a>2. 虚拟化技术概述</h1><h2 id="2-1-虚拟化定义"><a href="#2-1-虚拟化定义" class="headerlink" title="2.1 虚拟化定义"></a>2.1 虚拟化定义</h2><p>虚拟内存技术：在磁盘存储空间划分一部分作为内存的中转空间，负责存储内存中存放不下且暂时不用的数据，当程序用到这些数据时，再将他们从磁盘换入内存。</p>
<p><strong>三层含义：</strong></p>
<ul>
<li>虚拟化的对象是各种各样的资源</li>
<li>经过虚拟化后的罗技资源对用户隐藏了不必要的细节</li>
<li>用户可以在虚拟环境中实现其在真实环境中的部分或者全部功能</li>
</ul>
<p>IBM定义：</p>
<p>1） 虚拟化是资源的逻辑表示，它不受物理限制的约束</p>
<p><img src="/images/包罗万象的虚拟化.PNG" alt="image"></p>
<h3 id="虚拟化的常见类型："><a href="#虚拟化的常见类型：" class="headerlink" title="虚拟化的常见类型："></a>虚拟化的常见类型：</h3><ul>
<li>基础设施虚拟化（网络虚拟化、存储虚拟化）</li>
<li>系统虚拟化（一台物理机运行多个独立的操作系统）</li>
</ul>
<p><img src="/images/系统虚拟化.PNG" alt="image"></p>
<ul>
<li>软件虚拟化（应用虚拟化、高级语言虚拟化）</li>
</ul>
<h2 id="2-2-服务器虚拟化"><a href="#2-2-服务器虚拟化" class="headerlink" title="2.2 服务器虚拟化"></a>2.2 服务器虚拟化</h2><p><img src="/images/服务器虚拟化.PNG" alt="image"></p>
<h3 id="虚拟化的典型实现"><a href="#虚拟化的典型实现" class="headerlink" title="虚拟化的典型实现"></a>虚拟化的典型实现</h3><p><img src="/images/服务器虚拟化的实现方式.PNG" alt="image"></p>
<h3 id="虚拟化的关键特性"><a href="#虚拟化的关键特性" class="headerlink" title="虚拟化的关键特性"></a>虚拟化的关键特性</h3><ul>
<li>多实例</li>
<li>隔离性</li>
<li>封装性</li>
<li>高性能</li>
</ul>
<h3 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h3><ul>
<li>CPU虚拟化</li>
</ul>
<p><img src="/images/x86体系结构下的软件CPU虚拟化.PNG" alt="image"></p>
<ul>
<li>内存虚拟化</li>
</ul>
<p><img src="/images/内存虚拟化.PNG" alt="image"></p>
<p><img src="/images/内存虚拟化的两种方法.PNG" alt="image"></p>
<ul>
<li>设备与I/O虚拟化</li>
</ul>
<p><img src="/images/设备与IO虚拟化.PNG" alt="image"></p>
<p><img src="/images/网络接口虚拟化.PNG" alt="image"></p>
<ul>
<li>虚拟机实时迁移</li>
</ul>
<p><img src="/images/实时迁移技术.PNG" alt="image"></p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><ul>
<li>把应用分为三种类型：</li>
</ul>
<ol>
<li>处理器密集型</li>
<li>内存密集型</li>
<li>输入/输出密集型</li>
</ol>
<h3 id="技术优势"><a href="#技术优势" class="headerlink" title="技术优势"></a>技术优势</h3><ol>
<li>降低运营成本</li>
<li>提高应用兼容性</li>
<li>加速应用部署</li>
<li>提高服务可用性</li>
<li>提升资源利用率</li>
<li>动态调度资源（实时迁移）</li>
<li>降低能源消耗（关闭利用率不高的服务器）</li>
</ol>
<h1 id="3-虚拟化的关键技术"><a href="#3-虚拟化的关键技术" class="headerlink" title="3. 虚拟化的关键技术"></a>3. 虚拟化的关键技术</h1><p><img src="/images/虚拟化解决方案生命周期示意图.PNG" alt="image"></p>
<h2 id="3-1-创建虚拟化解决方案"><a href="#3-1-创建虚拟化解决方案" class="headerlink" title="3.1 创建虚拟化解决方案"></a>3.1 创建虚拟化解决方案</h2><h3 id="创建基本虚拟镜像"><a href="#创建基本虚拟镜像" class="headerlink" title="创建基本虚拟镜像"></a>创建基本虚拟镜像</h3><ul>
<li><p>虚拟机是指通过虚拟化软件套件模拟的、具有完整硬件功能的、运行在一个隔离环境中的逻辑计算机系统。</p>
</li>
<li><p>虚拟镜像主要使用场景：开发和测试环境（方便使用虚拟镜像恢复到需要的状态）</p>
</li>
<li><p>虚拟镜像种类：停机状态下创建的镜像（磁盘数据）、运行过程中创建的镜像（磁盘数据+内存数据）</p>
</li>
<li><p>创建一个最基本的虚拟镜像的流程：</p>
</li>
</ul>
<ol>
<li>创建虚拟机</li>
<li>安装操作系统</li>
<li>关停虚拟机</li>
</ol>
<p><img src="/images/创建虚拟镜像示意图.PNG" alt="image"></p>
<h4 id="创建虚拟器件镜像（主要应用：软件发布）"><a href="#创建虚拟器件镜像（主要应用：软件发布）" class="headerlink" title="创建虚拟器件镜像（主要应用：软件发布）"></a>创建虚拟器件镜像（主要应用：软件发布）</h4><p>虚拟器件包括了预安装、预配置的操作系统、中间件和应用的最小化的虚拟机。</p>
<p><img src="/images/虚拟器件结构图.PNG" alt="image"></p>
<p><img src="/images/虚拟器件创建流程图.PNG" alt="image"></p>
<h4 id="发布虚拟器件镜像（统一标准：OVF）"><a href="#发布虚拟器件镜像（统一标准：OVF）" class="headerlink" title="发布虚拟器件镜像（统一标准：OVF）"></a>发布虚拟器件镜像（统一标准：OVF）</h4><p><img src="/images/OVF结构示意图.PNG" alt="image"></p>
<h4 id="管理虚拟器件镜像"><a href="#管理虚拟器件镜像" class="headerlink" title="管理虚拟器件镜像"></a>管理虚拟器件镜像</h4><p>镜像文件管理的目标：</p>
<ol>
<li>快速被检索到</li>
<li>减小公共仓库的磁盘使用量</li>
<li>对镜像进行版本控制</li>
</ol>
<p>在镜像管理系统上获取虚拟器件镜像的流程：</p>
<p><img src="/images/在镜像管理系统上获取虚拟器件镜像的流程.PNG" alt="image"></p>
<h4 id="迁移到虚拟化环境"><a href="#迁移到虚拟化环境" class="headerlink" title="迁移到虚拟化环境"></a>迁移到虚拟化环境</h4><ul>
<li>迁移服务存在的风险</li>
</ul>
<ol>
<li>开发人员的流动性，可能已经找不到以前开发团队的相关人员</li>
<li>服务队系统的兼容性问题</li>
</ol>
<p>P2V就是指物理到虚拟，它是指操作系统、应用程序和数据从物理计算机的运行环境迁移到虚拟环境中（整体性的解决方案避险了上述风险）。</p>
<p><img src="/images/P2V示意图.PNG" alt="image"></p>
<h2 id="3-2-部署虚拟化解决方案"><a href="#3-2-部署虚拟化解决方案" class="headerlink" title="3.2 部署虚拟化解决方案"></a>3.2 部署虚拟化解决方案</h2><h3 id="规划部署环境"><a href="#规划部署环境" class="headerlink" title="规划部署环境"></a>规划部署环境</h3><p>构建虚拟化环境的三个步骤：</p>
<ol>
<li>投资回报分析</li>
<li>资源规划（计算资源、存储资源和网络资源）</li>
<li>虚拟化平台厂商以及产品的选择</li>
</ol>
<h3 id="部署虚拟器件"><a href="#部署虚拟器件" class="headerlink" title="部署虚拟器件"></a>部署虚拟器件</h3><p><img src="/images/部署虚拟器件流程图.PNG" alt="image"></p>
<h3 id="激活虚拟器件"><a href="#激活虚拟器件" class="headerlink" title="激活虚拟器件"></a>激活虚拟器件</h3><p><img src="/images/自动化激活单个虚拟器件.PNG" alt="image"></p>
<h2 id="3-3-管理虚拟化解决方案"><a href="#3-3-管理虚拟化解决方案" class="headerlink" title="3.3 管理虚拟化解决方案"></a>3.3 管理虚拟化解决方案</h2><h3 id="集中监控"><a href="#集中监控" class="headerlink" title="集中监控"></a>集中监控</h3><ul>
<li>功能</li>
</ul>
<ol>
<li>能够集中监控数据中心的所有资源</li>
<li>能够集中监控所有的虚拟器件上运行的解决方案和流程</li>
</ol>
<h3 id="快捷管理"><a href="#快捷管理" class="headerlink" title="快捷管理"></a>快捷管理</h3><ul>
<li>管理员下达的管理指令主要针对三种类型的实体：</li>
</ul>
<ol>
<li>基础设施（开关物理机、配置网络）</li>
<li>虚拟机（开关虚拟机、调整虚拟机资源、迁移虚拟机、快照）</li>
<li>虚拟器件内的应用、软件、解决方案</li>
</ol>
<h3 id="动态优化"><a href="#动态优化" class="headerlink" title="动态优化"></a>动态优化</h3><ul>
<li>针对的问题：在虚拟化环境中，如何根据应用、服务负载的变化为其所在的虚拟机及时、有效地分配虚拟化环境中的资源，保证既不会因为资源缺乏而影响业务系统运行，也不会造成严重的资源浪费。</li>
</ul>
<h3 id="高效备份"><a href="#高效备份" class="headerlink" title="高效备份"></a>高效备份</h3><ul>
<li>主流的备份机制：</li>
</ul>
<ol>
<li>虚拟机上备份</li>
<li>虚拟机外备份</li>
</ol>
<h1 id="5-云计算技术概述"><a href="#5-云计算技术概述" class="headerlink" title="5. 云计算技术概述"></a>5. 云计算技术概述</h1><h2 id="5-1-元计算的概念"><a href="#5-1-元计算的概念" class="headerlink" title="5.1 元计算的概念"></a>5.1 元计算的概念</h2><h3 id="走近云计算"><a href="#走近云计算" class="headerlink" title="走近云计算"></a>走近云计算</h3><ul>
<li>相关案例</li>
</ul>
<p><img src="/images/云计算案例一.PNG" alt="image"></p>
<p><img src="/images/云计算案例二.PNG" alt="image"></p>
<h3 id="云计算的定义"><a href="#云计算的定义" class="headerlink" title="云计算的定义"></a>云计算的定义</h3><h4 id="云计算的来源"><a href="#云计算的来源" class="headerlink" title="云计算的来源"></a>云计算的来源</h4><ul>
<li>云计算名字来源：在互联网初期，用一朵云来表示互联网，选择一个名词来表示基于互联网的新一代计算方式就选择了“云计算”</li>
</ul>
<p><img src="/images/云计算中的云.PNG" alt="image"></p>
<h4 id="什么是云计算"><a href="#什么是云计算" class="headerlink" title="什么是云计算"></a>什么是云计算</h4><p>云计算是一种能够将动态伸缩的虚拟化资源通过互联网以服务的方式提供给用户的计算模式，用户不需要知道如何管理那些支持云计算的基础设施。</p>
<h4 id="云计算的特征"><a href="#云计算的特征" class="headerlink" title="云计算的特征"></a>云计算的特征</h4><p>在云计算的定义中，有四个关键要素：</p>
<ul>
<li>硬件和软件都是资源</li>
</ul>
<p><img src="/images/云计算的特征.PNG" alt="image"></p>
<ul>
<li>这些资源都可以根据需要进行动态扩展和配置</li>
<li>这些资源在物理上以分布式的共享方式存在，在最终在逻辑上以单一整体的形式呈现。</li>
</ul>
<h3 id="云计算的分类"><a href="#云计算的分类" class="headerlink" title="云计算的分类"></a>云计算的分类</h3><ul>
<li>按服务类型分类</li>
</ul>
<ol>
<li>基础设施云</li>
<li>平台云</li>
<li>应用云（为用户提供可以直接为其所用的应用）</li>
</ol>
<p><img src="/images/按服务类型划分云计算.PNG" alt="image"></p>
<ul>
<li>按服务方式分类（按照云计算提供者和使用者的所属关系为划分标准）</li>
</ul>
<ul>
<li>共有云（用户共享云提供商所拥有的资源）</li>
<li>私有云（为企业或组织锁专有的云计算换将）</li>
<li>混合云（公有云和私有云的混合）</li>
</ul>
<p><img src="/images/云计算的服务方式.PNG" alt="image"></p>
<h3 id="相关概念解析"><a href="#相关概念解析" class="headerlink" title="相关概念解析"></a>相关概念解析</h3><ul>
<li>并行计算</li>
</ul>
<p><img src="/images/并行计算.PNG" alt="image"></p>
<ul>
<li>网格计算 </li>
</ul>
<p><img src="/images/网格计算.PNG" alt="image"></p>
<ul>
<li>效用计算</li>
</ul>
<p><img src="/images/效用计算.PNG" alt="image"></p>
<h2 id="5-2-云计算的优势与带来的变革"><a href="#5-2-云计算的优势与带来的变革" class="headerlink" title="5.2 云计算的优势与带来的变革"></a>5.2 云计算的优势与带来的变革</h2><h4 id="云计算的优势"><a href="#云计算的优势" class="headerlink" title="云计算的优势"></a>云计算的优势</h4><ol>
<li>优化产业布局（将企业原先自给自足的IT运用模式改变为由云计算提供商按需供给的模式）</li>
<li>推进专业分工</li>
<li>提升资源利用率（与其他应用共享这个平台提供的服务和资源）</li>
<li>减少初期投资（云计算将代替传统的企业专有数据中心）</li>
<li>降低管理开销（一切工作交由云平台自动完成）</li>
</ol>
<h4 id="云计算带来的变革"><a href="#云计算带来的变革" class="headerlink" title="云计算带来的变革"></a>云计算带来的变革</h4><p><img src="/images/云计算产业结构中的角色.PNG" alt="image"></p>
<ol>
<li>硬件提供商</li>
<li>基础软件提供商（操作系统和中间件）</li>
<li>云提供商（向下采购（或者通过咨询服务的方式建议云服务提供商和企业机构用户采购））硬件提供商以及基础软件提供商的硬件和软件产品，向上为云服务提供商构建公有云的解决方案，为企业机构用户提供构建私有云的解决方案。）</li>
</ol>
<ul>
<li><ol>
<li>具有丰富的硬件系统集成经验</li>
</ol>
</li>
<li><ol>
<li>具有丰富的软件系统集成经验（硬件是云计算的躯体，软件是云计算的灵魂）</li>
</ol>
</li>
<li><ol>
<li>具有丰富的行业背景</li>
</ol>
</li>
</ul>
<ol>
<li>云服务提供商（提供适合市场需求的云计算环境）</li>
<li>应用提供商（所提供的服务运行在云中，并且是以服务的方式通过互联网提供的）</li>
<li>个人用户（从主要使用软件变为主要使用服务）</li>
<li>企业机构用户（不必在拥有自己的数据中心，降低成本）</li>
</ol>
<h2 id="5-3-云计算产生的原动力"><a href="#5-3-云计算产生的原动力" class="headerlink" title="5.3 云计算产生的原动力"></a>5.3 云计算产生的原动力</h2><p><img src="/images/云计算产生的原动力.PNG" alt="image"></p>
<h1 id="6-云架构"><a href="#6-云架构" class="headerlink" title="6. 云架构"></a>6. 云架构</h1><p>要保证所提供服务的可伸缩性、可用性和安全性</p>
<h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><h3 id="云架构的基本层次"><a href="#云架构的基本层次" class="headerlink" title="云架构的基本层次"></a>云架构的基本层次</h3><p>云计算中的云分为：基础设施云、云平台和应用云</p>
<p><img src="/images/云架构层次示意图.PNG" alt="image"></p>
<ul>
<li>基础设施层：经过虚拟化后的硬件资源和相关管理功能的集合。</li>
<li>平台层：基于基础设施层和应用层之间，它是具有通用型和可复用性软件资源的集合，为云应用提供了开发、运行、管理和监控的环境。</li>
<li>应用层：通过网络交付给用户 </li>
</ul>
<h3 id="云架构的服务层次"><a href="#云架构的服务层次" class="headerlink" title="云架构的服务层次"></a>云架构的服务层次</h3><ol>
<li>基础设施即服务</li>
</ol>
<ul>
<li>交付给用户的是基本的基础设施资源（存储、计算、网络）</li>
</ul>
<ol>
<li>平台即服务</li>
</ol>
<ul>
<li>交付给用户的是丰富的“云中间件”资源（应用容器、数据库和消息处理）</li>
<li>面向的用户不是普通的终端用户，而是软件开发人员，他们可以充分利用这些开放的资源来开发定制化的应用。</li>
</ul>
<ol>
<li>软件即服务</li>
</ol>
<ul>
<li><p>交付给用户的是定制化的软件</p>
</li>
<li><p>特征</p>
</li>
<li><ol>
<li>用户不需要在本地安装该软件的副本</li>
</ol>
</li>
<li><ol>
<li>软件通过服务的方式通过网络交付给用户</li>
</ol>
</li>
<li><ol>
<li>虽然是面向多个用户，但是每个用户都感觉是独自占有该服务</li>
</ol>
</li>
</ul>
<h2 id="6-2-基础设施层"><a href="#6-2-基础设施层" class="headerlink" title="6.2 基础设施层"></a>6.2 基础设施层</h2><h3 id="基础设施层的基本功能"><a href="#基础设施层的基本功能" class="headerlink" title="基础设施层的基本功能"></a>基础设施层的基本功能</h3><ul>
<li>功能（总）：能够使经过虚拟化后的计算济源、存储资源和网络资源能够以基础设施即服务的方式通过网络被用户使用和管理</li>
<li>功能（分）：</li>
</ul>
<ol>
<li>资源抽象</li>
<li>资源监控（负载管理的前提）</li>
<li>负载管理</li>
</ol>
<p><img src="/images/负载均衡效果.PNG" alt="image"></p>
<ol>
<li>数据管理（完整性、可靠性、可管理性）</li>
<li>资源部署（通过自动化部署流程将资源交付给上层应用的过程）</li>
</ol>
<ul>
<li>动态部署应用场景：</li>
<li><ol>
<li>动态可伸缩性</li>
</ol>
</li>
<li><ol>
<li>故障恢复和硬件维护</li>
</ol>
</li>
</ul>
<ol>
<li>安全管理（保证基础设施资源被合法的访问和使用）</li>
<li>计费管理（按量计费）</li>
</ol>
<h3 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h3><h4 id="平台层的基本功能"><a href="#平台层的基本功能" class="headerlink" title="平台层的基本功能"></a>平台层的基本功能</h4><ol>
<li>开发测试环境</li>
</ol>
<p><img src="/images/传统平台和云平台解决方案.PNG" alt="image"></p>
<ol>
<li>运行时环境（隔离性、可伸缩性和用户间隔离）</li>
<li>运营环境</li>
</ol>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>种类：</p>
<ol>
<li>面向大众的标准应用</li>
<li>为了某个领域的客户而专门开发的客户应用</li>
<li>由第三方的独立软件开发商在云计算平台层上开发的满足用户多元化需求的应用</li>
</ol>
<p>特征：</p>
<ul>
<li>可以通过浏览器访问，或者具有开放的API，允许用户或者瘦客户端的调用</li>
<li>用户在使用云服务时，不需要进行一次性投入，只需要在使用的过程中按照其实际的使用情况付费</li>
<li>云应用要求高度整合</li>
</ul>
<h1 id="7-云计算的关键技术和挑战"><a href="#7-云计算的关键技术和挑战" class="headerlink" title="7. 云计算的关键技术和挑战"></a>7. 云计算的关键技术和挑战</h1><h2 id="7-1-云计算的关键技术"><a href="#7-1-云计算的关键技术" class="headerlink" title="7.1 云计算的关键技术"></a>7.1 云计算的关键技术</h2><h3 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h3><p><img src="/images/并行部署系统架构.PNG" alt="image"></p>
<h3 id="资源调度"><a href="#资源调度" class="headerlink" title="资源调度"></a>资源调度</h3><p><img src="/images/资源调度.PNG" alt="image"></p>
<h3 id="多租户技术"><a href="#多租户技术" class="headerlink" title="多租户技术"></a>多租户技术</h3><p><img src="/images/多租户技术.PNG" alt="image"></p>
<h3 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h3><p><img src="/images/mapreduce框架的基本处理流程.PNG" alt="image"></p>
<h3 id="大规模消息通信"><a href="#大规模消息通信" class="headerlink" title="大规模消息通信"></a>大规模消息通信</h3><h3 id="大规模分布式存储"><a href="#大规模分布式存储" class="headerlink" title="大规模分布式存储"></a>大规模分布式存储</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/11/逆序字符串的最长公共子序列长度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/11/逆序字符串的最长公共子序列长度/" itemprop="url">逆序字符串的最长公共子序列长度</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-11T14:28:57+08:00">
                2017-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="题目：给出一个以空格作为分隔符的字符串，求其与其空格分割的逆序字符串的最长公共子序列长度。"><a href="#题目：给出一个以空格作为分隔符的字符串，求其与其空格分割的逆序字符串的最长公共子序列长度。" class="headerlink" title="题目：给出一个以空格作为分隔符的字符串，求其与其空格分割的逆序字符串的最长公共子序列长度。"></a>题目：给出一个以空格作为分隔符的字符串，求其与其空格分割的逆序字符串的最长公共子序列长度。</h1><h2 id="输入案例"><a href="#输入案例" class="headerlink" title="输入案例"></a>输入案例</h2><p>例如：</p>
<p>输入 2017 11 02</p>
<p>其逆序字符串为 02 11 2017</p>
<p>输出 6（2 11 2）</p>
<h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><p>经常会遇到复杂问题不能简单地分解成几个子问题，而会分解出一系列的子问题。简单地采用把大问题分解成子问题，并综合子问题的解导出大问题的解的方法，问题求解耗时会按问题规模呈幂级数增加。</p>
<p>为了节约重复求相同子问题的时间，引入一个数组，不管它们是否对最终解有用，把所有子问题的解存于该数组中，这就是动态规划法所采用的基本方法。</p>
<h3 id="最长公共子子序列问题（LCS-subSequence）"><a href="#最长公共子子序列问题（LCS-subSequence）" class="headerlink" title="最长公共子子序列问题（LCS_subSequence）"></a>最长公共子子序列问题（LCS_subSequence）</h3><p><strong>问题：</strong> 求两字符序列的最长公共字符子序列</p>
<p><strong>问题描述：</strong>字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列X=“x0，x1，…，xm-1”，序列Y=“y0，y1，…，yk-1”是X的子序列，存在X的一个严格递增下标序列[i0，i1，…，ik-1]，使得对所有的j=0，1，…，k-1，有xij=yj。例如，X=“ABCBDAB”，Y=“BCDB”是X的一个子序列。</p>
<p>考虑最长公共子序列问题如何分解成子问题，设A=“a0，a1，…，am-1”，B=“b0，b1，…，bm-1”，并Z=“z0，z1，…，zk-1”为它们的最长公共子序列。不难证明有以下性质：</p>
<ol>
<li><p>如果am-1=bn-1，则zk-1=am-1=bn-1，且“z0，z1，…，zk-2”是“a0，a1，…，am-2”和“b0，b1，…，bn-2”的一个最长公共子序列；</p>
</li>
<li><p>如果am-1!=bn-1，则若zk-1!=am-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列；</p>
</li>
<li><p>如果am-1!=bn-1，则若zk-1!=bn-1，蕴涵“z0，z1，…，zk-1”是“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列。</p>
</li>
</ol>
<p>这样，在找A和B的公共子序列时，如有am-1=bn-1，则进一步解决一个子问题，找“a0，a1，…，am-2”和“b0，b1，…，bm-2”的一个最长公共子序列；如果am-1!=bn-1，则要解决两个子问题，找出“a0，a1，…，am-2”和“b0，b1，…，bn-1”的一个最长公共子序列和找出“a0，a1，…，am-1”和“b0，b1，…，bn-2”的一个最长公共子序列，再取两者中较长者作为A和B的最长公共子序列。</p>
<p><strong>求解</strong></p>
<p>引进一个二维数组c[][]，用c[i][j]记录X[i]与Y[j]的LCS的长度，b[i][j]记录c[i][j]是通过哪一个子问题的值求得的，以决定搜索的方向。<br>我们是自底向上进行递推计算，那么在计算c[i,j]之前，c[i-1][j-1]，c[i-1][j]与c[i][j-1]均已计算出来。此时我们根据X[i] = Y[j]还是X[i] != Y[j]，就可以计算出c[i][j]。 </p>
<p>问题的递归式写成： </p>
<p><img src="/images/逆序字符串的最长公共子序列长度.png" alt="image"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">package dx;</div><div class="line"></div><div class="line">import java.util.Scanner;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dx on 2017/10/11.</div><div class="line"> */</div><div class="line">public class Qunaer &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        //用来记录长度</div><div class="line">        int count = 0;</div><div class="line">        Scanner scanner = new Scanner(System.in);</div><div class="line">        String string = scanner.nextLine();</div><div class="line"></div><div class="line">        String[] value = string.split(&quot; &quot;);</div><div class="line">        String[] reverseValue = new String[value.length];</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</div><div class="line">            reverseValue[i] = new StringBuilder(value[i]).reverse().toString();</div><div class="line">        &#125;</div><div class="line">        StringBuilder stringBuilder = new StringBuilder();</div><div class="line">        for (int i = 0; i &lt; value.length; i++) &#123;</div><div class="line">            stringBuilder.append(reverseValue[i]);</div><div class="line">            if (i != value.length - 1)</div><div class="line">                stringBuilder.append(&quot; &quot;);</div><div class="line">        &#125;</div><div class="line">        String reverseString = stringBuilder.reverse().toString();</div><div class="line"></div><div class="line">        int[][] re = longestCommonSubsequence(string, reverseString);</div><div class="line">        System.out.println(re[string.length()][string.length()]);</div><div class="line">        print(re,string,reverseString,string.length(),reverseString.length());</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    // 假如返回两个字符串的最长公共子序列的长度</div><div class="line">    public static int[][] longestCommonSubsequence(String str1, String str2) &#123;</div><div class="line">        int[][] matrix = new int[str1.length() + 1][str2.length() + 1];//建立二维矩阵</div><div class="line">        // 初始化边界条件</div><div class="line">        for (int i = 0; i &lt;= str1.length(); i++) &#123;</div><div class="line">            matrix[i][0] = 0;//每行第一列置零</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        for (int j = 0; j &lt;= str2.length(); j++) &#123;</div><div class="line">            matrix[0][j] = 0;//每列第一行置零</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // 填充矩阵</div><div class="line">        for (int i = 1; i &lt;= str1.length(); i++) &#123;</div><div class="line">            for (int j = 1; j &lt;= str2.length(); j++) &#123;</div><div class="line">                if (str1.charAt(i - 1) == str2.charAt(j - 1)) &#123;</div><div class="line">                    matrix[i][j] = matrix[i - 1][j - 1] + 1;</div><div class="line">                &#125; else &#123;</div><div class="line">                    matrix[i][j] = (matrix[i - 1][j] &gt;= matrix[i][j - 1] ? matrix[i - 1][j]</div><div class="line">                            : matrix[i][j - 1]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return matrix;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //根据矩阵输出LCS</div><div class="line">    public static void print(int[][] opt, String X, String Y, int i, int j) &#123;</div><div class="line">        if (i == 0 || j == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (X.charAt(i - 1) == Y.charAt(j - 1)) &#123;</div><div class="line">            print(opt, X, Y, i - 1, j - 1);</div><div class="line">            System.out.print(X.charAt(i - 1));</div><div class="line">        &#125; else if (opt[i - 1][j] &gt;= opt[i][j]) &#123;</div><div class="line">            print(opt, X, Y, i - 1, j);</div><div class="line">        &#125; else &#123;</div><div class="line">            print(opt, X, Y, i, j - 1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/26/Java参数传递/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/26/Java参数传递/" itemprop="url">Java参数传递</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-26T14:41:53+08:00">
                2017-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpecialNote/" itemprop="url" rel="index">
                    <span itemprop="name">SpecialNote</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JAVA属于值传递还是引用传递？</p>
<p>不管你传的是什么,传过去的都只是一个副本而已,这个副本作为方法的局部变量保存在栈中。</p>
<p>如果传的是基本数据类型,修改这个值并不会影响作为参数传进来的那个变量,因为你修改的是方法的局部变量,是一个副本。</p>
<p>如果传的是一个对象的引用,也是一样的,也是一个副本,但是这个副本和作为参数传进来的那个引用指向的是内存中的同一个对象,所以你通过这个副本也可以操作那个对象。但是如果你修改这个引用本身,比如让他指向内存中的另外一个对象,原来作为参数传进来的那个引用不会受到影响。</p>
<p>我觉得弄明白这些就行了,说值传递或引用传递都无所谓,但是说值传递更适合一些,这个值可以是引用也可以是基本数据类型。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/22/正确实现Java中的HashCode-一致性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/22/正确实现Java中的HashCode-一致性/" itemprop="url">正确实现Java中的HashCode-一致性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-22T14:19:13+08:00">
                2017-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpecialNote/" itemprop="url" rel="index">
                    <span itemprop="name">SpecialNote</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>默认情况下，用户自定义实现HashCode时，它们会使用相同的字段，但有一个细节需要考虑。</p>
<h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p>第一是一致性要求。它应该经过非常严格的计算。如果有字段产生了变化，哈希码也应该允许变化（对于可变类来说，这往往是不可避免的），依赖哈希的数据结构并未准备应付这种情况。</p>
<p>正如我们所知哈希码用于确定一个元素的桶，但是如果哈希相关的字段发生变化，并不会立即重新计算哈希码，而且内部的数组也不会更新。</p>
<p>这就意味着，再对一个相等的对象甚至同一个对象的查询会失败！这个数据结构会计算当前的哈希码，这个哈希码与实例存入时的哈希码并不相同，这直接导致找错了桶。</p>
<p><strong>小结：最好不要用可变的字段来计算哈希码！</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/22/Java高并发：锁概览/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/22/Java高并发：锁概览/" itemprop="url">Java高并发：锁概览</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-22T13:52:48+08:00">
                2017-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在学习或者使用Java的过程中进程会遇到各种各样的锁的概念：公平锁、非公平锁、自旋锁、可重入锁、偏向锁、轻量级锁、重量级锁、读写锁、互斥锁等待。这里整理了Java中的各种锁，若有不足之处希望大家在下方留言探讨。</p>
<h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的先后顺序来一次获得锁。</p>
<p>公平锁的好处是等待锁的线程不会饿死，但是整体效率相对低一些；非公平锁的好处是整体效率相对高一些，但是有些线程可能会饿死或者说很早就在等待锁，但要等很久才会获得锁。其中的原因是公平锁是严格按照请求所的顺序来排队获得锁的，而非公平锁时可以抢占的，即如果在某个时刻有线程需要获取锁，而这个时候刚好锁可用，那么这个线程会直接抢占，而这时阻塞在等待队列的线程则不会被唤醒。</p>
<p>公平锁可以使用new ReentrantLock(true)实现。</p>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态装换需要耗费很多的处理器时间，<strong>对于代码简单的同步块（如被synchronized修饰的getter()和setter()方法），状态转换消耗的时间有可能比用户代码执行的时间还要长。</strong></p>
<p>虚拟机的开发团队注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间挂起和恢复现场并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下“，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。<strong>为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。</strong></p>
<p>自旋等待不能代替阻塞。<strong>自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋当代的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会拜拜浪费处理器资源。</strong>因此，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当使用传统的方式去挂起线程了。</p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK6中已经变为默认开启，并且引入了自适应的自旋锁。自适应意味着自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p>
<p><strong>自旋是在轻量级锁中使用的，在重量级锁中，线程不使用自旋。</strong></p>
<p><strong>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100次循环。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</strong></p>
<h1 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h1><p>锁消除是虚拟机JIT在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判断依据是来源于<strong>逃逸分析</strong>的数据支持，<strong>如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而能被其他线程访问到，那就可以把他们当做栈上数据对待，认为他们是线程私有的，同步加锁自然就无需进行。</strong></p>
<p>来看这样一个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public String concatString(String s1, String s2, String s3)</div><div class="line">   &#123;</div><div class="line">       StringBuffer sb = new StringBuffer();</div><div class="line">       sb.append(s1);</div><div class="line">       sb.append(s2);</div><div class="line">       sb.append(s3);</div><div class="line">       return sb.toString();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>可以知道StringBuffer(线程安全的)的append方法定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public synchronized StringBuffer append(StringBuffer sb) &#123;</div><div class="line">        super.append(sb);</div><div class="line">        return this;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>也就是说在append方法中涉及了同步操作。但是可以观察到sb对象它的作用域被限制在方法的内部，也就是sb对象不会“逃逸”出去，其他线程无法访问。因此，虽然这里有锁，但是可以被安全的消除，在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了。</p>
<h1 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h1><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制的尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁禁止，那等待的线程也能尽快拿到锁。大部分情况下，这些都是正确的。<strong>但是，如果一些列的联系操作都是同一个对象反复加上和解锁，甚至加锁操作是出现在循环体中的，那么即使没有线程竞争，频繁地进行互斥同步操作也导致不必要的性能损耗。</strong></p>
<p>举个案例，类似锁消除的append()方法。如果StringBuffer sb = new StringBuffer();定义在方法体之外，那么就会有线程竞争，但是每个append()操作都对同一个对象反复加锁解锁，那么虚拟机探测到有这样的情况的话，会把加锁同步的范围扩展到整个操作序列的外部，即扩展到第一个append()操作之前和最后一个append()操作之后，这样的一个锁范围扩展的操作就称之为锁粗化。</p>
<h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。</p>
<p>在JAVA环境下 ReentrantLock 和synchronized 都是可重入锁。可重入锁最大的作用是避免死锁。</p>
<h2 id="类锁和对象锁"><a href="#类锁和对象锁" class="headerlink" title="类锁和对象锁"></a>类锁和对象锁</h2><p>类锁：在方法上加上static synchronized的锁，或者synchronized(xxx.class)的锁。如下代码中的method1和method2：</p>
<p>对象锁：参考method4, method5,method6.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">public class LockStrategy</div><div class="line">&#123;</div><div class="line">    //对象</div><div class="line">    public Object object1 = new Object();</div><div class="line">    //类锁</div><div class="line">    public static synchronized void method1()&#123;&#125;</div><div class="line">    //类锁</div><div class="line">    public void method2()&#123;</div><div class="line">        synchronized(LockStrategy.class)&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    //对象锁</div><div class="line">    public synchronized void method4()&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    //对象锁</div><div class="line">    public void method5()</div><div class="line">    &#123;</div><div class="line">        synchronized(this)&#123;&#125;</div><div class="line">    &#125;</div><div class="line">    //对象锁</div><div class="line">    public void method6()</div><div class="line">    &#123;</div><div class="line">        synchronized(object1)&#123;&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面做一道习题来加深一下对对象锁和类锁的理解.<br>有一个类这样定义:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class SynchronizedTest</div><div class="line">&#123;</div><div class="line">    public synchronized void method1()&#123;&#125;</div><div class="line">    public synchronized void method2()&#123;&#125;</div><div class="line">    public static synchronized void method3()&#123;&#125;</div><div class="line">    public static synchronized void method4()&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么，有SynchronizedTest的两个实例a和b，对于一下的几个选项有哪些能被一个以上的线程同时访问呢？(BE)</p>
<ul>
<li>A. a.method1()(对象锁) vs. a.method2()(对象锁)</li>
<li>B. a.method1()(对象锁) vs. b.method1()(对象锁)</li>
<li>C. a.method3()(类锁) vs. b.method4()(类锁)</li>
<li>D. a.method3()(类锁) vs. b.method3()(类锁)</li>
<li>E. a.method1()(对象锁) vs. a.method3()(类锁)</li>
</ul>
<h1 id="偏向锁、轻量级锁和重量级锁"><a href="#偏向锁、轻量级锁和重量级锁" class="headerlink" title="偏向锁、轻量级锁和重量级锁"></a>偏向锁、轻量级锁和重量级锁</h1><p>synchronized的偏向锁、轻量级锁以及重量级锁是通过Java对象头实现的。博主在Java对象大小内幕浅析中提到了Java对象的内存布局分为：对象头、实例数据和对其填充，而对象头又可以分为”Mark Word”和类型指针klass。”Mark Word”是关键，默认情况下，其存储对象的HashCode、分代年龄和锁标记位。</p>
<p>这里说的都是以HotSpot虚拟机为基准的。首先来看一下”Mark Word”的内容：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>存储内容</th>
<th>标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>无锁</td>
<td>对象的hashCode、对象分代年龄、是否是偏向锁（0）</td>
<td>01</td>
</tr>
<tr>
<td>轻量级</td>
<td>指向栈中锁记录的指针</td>
<td>00</td>
</tr>
<tr>
<td>重量级</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td>（空）</td>
<td>11</td>
</tr>
<tr>
<td>偏向锁</td>
<td>偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁（1）</td>
<td>01</td>
</tr>
</tbody>
</table>
<p>偏向锁是JDK6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。</p>
<p>偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要同步。大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<p>当锁对象第一次被线程获取的时候，线程使用CAS操作把这个锁的线程ID记录再对象Mark Word之中，同时置偏向标志位1。以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需要简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。</p>
<p>如果线程使用CAS操作时失败则表示该锁对象上存在竞争并且这个时候另外一个线程获得偏向锁的所有权。当到达全局安全点（safepoint，这个时间点上没有正在执行的字节码）时获得偏向锁的线程被挂起，膨胀为轻量级锁（涉及Monitor Record，Lock Record相关操作，这里不展开），同时被撤销偏向锁的线程继续往下执行同步代码。</p>
<p>当有另外一个线程去尝试获取这个锁时，偏向模式就宣告结束。</p>
<p>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录(Lock Record)的空间，并将对象头中的Mard Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。如果自旋失败则锁会膨胀成重量级锁。如果自旋成功则依然处于轻量级锁的状态。</p>
<p>轻量级锁的解锁过程也是通过CAS操作来进行的，如果对象的Mark Word仍然指向线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中赋值的Displaced Mark Word替换回来，如果替换成功，整个同步过程就完成了，如果替换失败，就说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程。</p>
<p>轻量级锁提升程序同步性能的依据是：对于绝大部分的锁，在整个同步周期内都是不存在竞争的（区别于偏向锁）。这是一个经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，但如果存在锁竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁比传统的重量级锁更慢。</p>
<p>整个synchronized锁流程如下：</p>
<ol>
<li>检测Mark Word里面是不是当前线程的ID，如果是，表示当前线程处于偏向锁</li>
<li>如果不是，则使用CAS将当前线程的ID替换Mard Word，如果成功则表示当前线程获得偏向锁，置偏向标志位1</li>
<li>如果失败，则说明发生竞争，撤销偏向锁，进而升级为轻量级锁。</li>
<li>当前线程使用CAS将对象头的Mark Word替换为锁记录指针，如果成功，当前线程获得锁</li>
<li>如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>
<li>如果自旋成功则依然处于轻量级状态。</li>
<li>如果自旋失败，则升级为重量级锁。</li>
</ol>
<h1 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h1><p>悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。<br>乐观锁：假定不会发生并发冲突，只在提交操作时检测是否违反数据完整性。（使用版本号或者时间戳来配合实现）</p>
<h1 id="共享锁和排它锁"><a href="#共享锁和排它锁" class="headerlink" title="共享锁和排它锁"></a>共享锁和排它锁</h1><p>共享锁：如果事务T对数据A加上共享锁后，则其他事务只能对A再加共享锁，不能加排它锁。获准共享锁的事务只能读数据，不能修改数据。<br>排它锁：如果事务T对数据A加上排它锁后，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。</p>
<h1 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h1><p>读写锁是一个资源能够被多个读线程访问，或者被一个写线程访问但不能同时存在读线程。Java当中的读写锁通过ReentrantReadWriteLock实现。具体使用方法这里不展开。</p>
<h1 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h1><p>所谓互斥锁就是指一次最多只能有一个线程持有的锁。在JDK中synchronized和JUC的Lock就是互斥锁。</p>
<h1 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h1><p>要保证现场安全，并不是一定就要进行同步，两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的。</p>
<ol>
<li>无状态编程。无状态代码有一些共同的特征：不依赖于存储在对上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非无状态的方法等。可以参考Servlet。</li>
<li>线程本地存储。可以参考ThreadLocal</li>
<li>volatile</li>
<li>CAS</li>
<li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/22/Java高并发：ReentrantLock-重入锁-以及公平性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/22/Java高并发：ReentrantLock-重入锁-以及公平性/" itemprop="url">Java高并发：ReentrantLock(重入锁)以及公平性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-22T13:47:47+08:00">
                2017-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/高并发/" itemprop="url" rel="index">
                    <span itemprop="name">高并发</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>ReentrantLock</strong>的实现不仅可以替代隐式的synchronized关键字，而且能够提供超过关键字本身的多种功能。</p>
<p>这里提到一个锁获取的公平性问题，如果在绝对时间上，先对锁进行获取的请求一定被先满足，那么这个锁是公平的，反之，是不公平的，也就是说等待时间最长的线程最有机会获取锁，也可以说锁的获取是有序的。ReentrantLock这个锁提供了一个构造函数，能够控制这个锁是否是公平的。</p>
<p>而锁的名字也是说明了这个锁具备了重复进入的可能，也就是说能够让当前线程多次的进行对锁的获取操作，这样的最大次数限制是Integer.MAX_VALUE，约21亿次左右。</p>
<p>事实上<strong>公平的锁机制往往没有非公平的效率高</strong>，因为公平的获取锁没有考虑到操作系统对线程的调度因素，这样造成JVM对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配。对于锁的快速且重复的获取过程中，连续获取的概率是非常高的，而公平锁会压制这种情况，虽然公平性得以保障，但是响应比却下降了，但是并不是任何场景都是以TPS作为唯一指标的，因为公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。</p>
<p><strong>可重入锁的最大作用：避免死锁</strong></p>
<h1 id="Java应用"><a href="#Java应用" class="headerlink" title="Java应用"></a>Java应用</h1><p>可重入锁，也叫做递归锁，指的是同一线程外层函数获得锁之后,内层递归函数仍然有获取该锁的代码，但不受影响。</p>
<p><strong>在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁</strong></p>
<h3 id="synchronized-Demo"><a href="#synchronized-Demo" class="headerlink" title="synchronized Demo"></a>synchronized Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">package dx.concurrent.reentrantlock;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dx on 2017/9/12.</div><div class="line"> */</div><div class="line">public class Test1 implements Runnable &#123;</div><div class="line"></div><div class="line">    public synchronized void get() &#123;</div><div class="line">        System.out.println(Thread.currentThread().getId());</div><div class="line">        set();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public synchronized void set() &#123;</div><div class="line">        System.out.println(Thread.currentThread().getId());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Test1 ss = new Test1();</div><div class="line">        new Thread(ss).start();</div><div class="line">        new Thread(ss).start();</div><div class="line">        new Thread(ss).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">10</div><div class="line">12</div><div class="line">12</div><div class="line">11</div><div class="line">11</div></pre></td></tr></table></figure>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">package dx.concurrent.reentrantlock;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dx on 2017/9/12.</div><div class="line"> */</div><div class="line">public class Test2 implements Runnable &#123;</div><div class="line">    ReentrantLock lock = new ReentrantLock();</div><div class="line"></div><div class="line">    public void get() &#123;</div><div class="line">        lock.lock();</div><div class="line">        System.out.println(Thread.currentThread().getId());</div><div class="line">        set();</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void set() &#123;</div><div class="line">        lock.lock();</div><div class="line">        System.out.println(Thread.currentThread().getId());</div><div class="line">        lock.unlock();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        Test2 ss = new Test2();</div><div class="line">        new Thread(ss).start();</div><div class="line">        new Thread(ss).start();</div><div class="line">        new Thread(ss).start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">10</div><div class="line">10</div><div class="line">12</div><div class="line">12</div><div class="line">11</div><div class="line">11</div></pre></td></tr></table></figure>
<h1 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h1><p>在ReentrantLock中，对于公平和非公平的定义是通过对同步器<strong>AbstractQueuedSynchronizer</strong>的扩展加以实现的，也就是在tryAcquire的实现上做了语义的控制。</p>
<h2 id="非公平实现语义"><a href="#非公平实现语义" class="headerlink" title="非公平实现语义"></a>非公平实现语义</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">final boolean nonfairTryAcquire(int acquires) &#123;</div><div class="line">           final Thread current = Thread.currentThread();</div><div class="line">           int c = getState();</div><div class="line">           //当前状态为初试状态，尝试设置初试状态</div><div class="line">           if (c == 0) &#123;</div><div class="line">               if (compareAndSetState(0, acquires)) &#123;</div><div class="line">                   setExclusiveOwnerThread(current);</div><div class="line">                   //如果状态设置成功后就返回</div><div class="line">                   return true;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">           //如果状态被设置，且获取锁的线程又是当前线程的时候，进行状态的自增；</div><div class="line">           else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">               int nextc = c + acquires;</div><div class="line">               if (nextc &lt; 0) // overflow</div><div class="line">                   throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">               setState(nextc);</div><div class="line">               return true;</div><div class="line">           &#125;</div><div class="line">           //如果未设置成功状态且当前线程不是获取锁的线程，那么返回失败。</div><div class="line">           return false;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<h3 id="公平的实现语义"><a href="#公平的实现语义" class="headerlink" title="公平的实现语义"></a>公平的实现语义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryAcquire(int acquires) &#123;</div><div class="line">	final Thread current = Thread.currentThread();</div><div class="line">	int c = getState();</div><div class="line">	if (c == 0) &#123;</div><div class="line">	//判断当前线程是否有前置线程在等待</div><div class="line">		if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123;</div><div class="line">			setExclusiveOwnerThread(current);</div><div class="line">			return true;</div><div class="line">		&#125;</div><div class="line">	&#125; else if (current == getExclusiveOwnerThread()) &#123;</div><div class="line">		int nextc = c + acquires;</div><div class="line">		if (nextc &lt; 0)</div><div class="line">			throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class="line">		setState(nextc);</div><div class="line">		return true;</div><div class="line">	&#125;</div><div class="line">	return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="释放语义"><a href="#释放语义" class="headerlink" title="释放语义"></a>释放语义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">protected final boolean tryRelease(int releases) &#123;</div><div class="line">	int c = getState() - releases;</div><div class="line">	if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">		throw new IllegalMonitorStateException();</div><div class="line">	boolean free = false;</div><div class="line">	if (c == 0) &#123;</div><div class="line">		free = true;</div><div class="line">		setExclusiveOwnerThread(null);</div><div class="line">	&#125;</div><div class="line">	setState(c);</div><div class="line">	return free;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述逻辑主要主要计算了释放状态后的值，如果为0则完全释放，返回true，反之仅是设置状态，返回false。</p>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dx on 2017/9/12.</div><div class="line"> */</div><div class="line">public class ReentrantLockTest &#123;</div><div class="line">    //公平锁</div><div class="line">    private static Lock fairLock = new ReentrantLock(true);</div><div class="line">    //非公平锁</div><div class="line">    private static Lock unfairLock = new ReentrantLock();</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void fair() &#123;</div><div class="line">        System.out.println(&quot;fair version&quot;);</div><div class="line"></div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            Thread thread = new Thread(new Job(fairLock));</div><div class="line">            //设置线程名字</div><div class="line">            thread.setName(&quot;&quot; + i);</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(5000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void unfair() &#123;</div><div class="line">        System.out.println(&quot;unfair version&quot;);</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            Thread thread = new Thread(new Job(unfairLock));</div><div class="line">            thread.setName(&quot;&quot; + i);</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(5000);</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Job implements Runnable &#123;</div><div class="line">        private Lock lock;</div><div class="line">        public Job(Lock lock) &#123;</div><div class="line">            this.lock = lock;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">                lock.lock();</div><div class="line">                try &#123;</div><div class="line">                    System.out.println(&quot;Lock by:&quot;</div><div class="line">                            + Thread.currentThread().getName());</div><div class="line">                &#125; finally &#123;</div><div class="line">                    System.out.println(&quot;unLock by:&quot;+Thread.currentThread().getName());</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回结果："><a href="#返回结果：" class="headerlink" title="返回结果："></a>返回结果：</h3><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">fair version</div><div class="line">Lock by:0</div><div class="line">Lock by:1</div><div class="line">Lock by:2</div><div class="line">Lock by:0</div><div class="line">Lock by:3</div><div class="line">Lock by:4</div><div class="line">Lock by:1</div><div class="line">Lock by:2</div><div class="line">Lock by:0</div><div class="line">Lock by:3</div><div class="line">Lock by:4</div><div class="line">Lock by:1</div><div class="line">Lock by:2</div><div class="line">Lock by:0</div><div class="line">Lock by:3</div><div class="line">Lock by:4</div><div class="line">Lock by:1</div><div class="line">Lock by:2</div><div class="line">Lock by:0</div><div class="line">Lock by:3</div><div class="line">Lock by:4</div><div class="line">Lock by:1</div><div class="line">Lock by:2</div><div class="line">Lock by:3</div><div class="line">Lock by:4</div></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">unfair version</div><div class="line">Lock by:0</div><div class="line">Lock by:0</div><div class="line">Lock by:0</div><div class="line">Lock by:2</div><div class="line">Lock by:2</div><div class="line">Lock by:2</div><div class="line">Lock by:2</div><div class="line">Lock by:2</div><div class="line">Lock by:0</div><div class="line">Lock by:0</div><div class="line">Lock by:1</div><div class="line">Lock by:1</div><div class="line">Lock by:1</div><div class="line">Lock by:1</div><div class="line">Lock by:1</div><div class="line">Lock by:3</div><div class="line">Lock by:3</div><div class="line">Lock by:3</div><div class="line">Lock by:3</div><div class="line">Lock by:3</div><div class="line">Lock by:4</div><div class="line">Lock by:4</div><div class="line">Lock by:4</div><div class="line">Lock by:4</div><div class="line">Lock by:4</div></pre></td></tr></table></figure>
<h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><p>仔细观察返回的结果(其中每个数字代表一个线程)，非公平的结果一个线程连续获取锁的情况非常多，而公平的结果连续获取的情况基本没有。那么在一个线程获取了锁的那一刻，究竟锁的公平性会导致锁有什么样的处理逻辑呢？<br>通过之前的同步器(AbstractQueuedSynchronizer)的介绍，在锁上是存在一个等待队列，sync队列，我们通过复写ReentrantLock的获取当前锁的sync队列，输出在ReentrantLock被获取时刻，当前的sync队列的状态。</p>
<h2 id="测试用例2"><a href="#测试用例2" class="headerlink" title="测试用例2"></a>测试用例2</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">import java.util.Collection;</div><div class="line">import java.util.concurrent.locks.Lock;</div><div class="line">import java.util.concurrent.locks.ReentrantLock;</div><div class="line"></div><div class="line">/**</div><div class="line"> * Created by dx on 2017/9/12.</div><div class="line"> */</div><div class="line">public class ReentrantLockTest2 &#123;</div><div class="line">    private static Lock fairLock = new ReentrantLock2(true);</div><div class="line">    private static Lock unfairLock = new ReentrantLock2();</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void fair() &#123;</div><div class="line">        System.out.println(&quot;fair version&quot;);</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            Thread thread = new Thread(new Job(fairLock)) &#123;</div><div class="line">                public String toString() &#123;</div><div class="line">                    return getName();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            thread.setName(&quot;&quot; + i);</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">        // sleep 5000ms</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(5000);</div><div class="line">        &#125; catch (InterruptedException ex) &#123;</div><div class="line">            ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Test</div><div class="line">    public void unfair() &#123;</div><div class="line">        System.out.println(&quot;unfair version&quot;);</div><div class="line">        for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">            Thread thread = new Thread(new Job(unfairLock)) &#123;</div><div class="line">                public String toString() &#123;</div><div class="line">                    return getName();</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">            thread.setName(&quot;&quot; + i);</div><div class="line">            thread.start();</div><div class="line">        &#125;</div><div class="line">        // sleep 5000ms</div><div class="line">        try &#123;</div><div class="line">            Thread.sleep(5000);</div><div class="line">        &#125; catch (InterruptedException ex) &#123;</div><div class="line">            ex.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Job implements Runnable &#123;</div><div class="line">        private Lock lock;</div><div class="line"></div><div class="line">        public Job(Lock lock) &#123;</div><div class="line">            this.lock = lock;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for (int i = 0; i &lt; 5; i++) &#123;</div><div class="line">                lock.lock();</div><div class="line">                try &#123;</div><div class="line">                    System.out.println(&quot;Lock by:&quot;</div><div class="line">                            + Thread.currentThread().getName() + &quot; and &quot;</div><div class="line">                            + ((ReentrantLock2) lock).getQueuedThreads()</div><div class="line">                            + &quot; waits.&quot;);</div><div class="line">                &#125; finally &#123;</div><div class="line">                    lock.unlock();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class ReentrantLock2 extends ReentrantLock &#123;</div><div class="line">        // Constructor Override</div><div class="line"></div><div class="line">        public ReentrantLock2(boolean flag) &#123;</div><div class="line">            super(flag);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public ReentrantLock2() &#123;</div><div class="line">            super();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private static final long serialVersionUID = 1773716895097002072L;</div><div class="line"></div><div class="line">        public Collection&lt;Thread&gt; getQueuedThreads() &#123;</div><div class="line">            return super.getQueuedThreads();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="返回结果：-1"><a href="#返回结果：-1" class="headerlink" title="返回结果："></a>返回结果：</h3><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">fair version</div><div class="line">fair version</div><div class="line">Lock by:1 and [0] waits.</div><div class="line">Lock by:0 and [1, 4, 3, 2] waits.</div><div class="line">Lock by:2 and [0, 1, 4, 3] waits.</div><div class="line">Lock by:3 and [2, 0, 1, 4] waits.</div><div class="line">Lock by:4 and [3, 2, 0, 1] waits.</div><div class="line">Lock by:1 and [4, 3, 2, 0] waits.</div><div class="line">Lock by:0 and [1, 4, 3, 2] waits.</div><div class="line">Lock by:2 and [0, 1, 4, 3] waits.</div><div class="line">Lock by:3 and [2, 0, 1, 4] waits.</div><div class="line">Lock by:4 and [3, 2, 0, 1] waits.</div><div class="line">Lock by:1 and [4, 3, 2, 0] waits.</div><div class="line">Lock by:0 and [1, 4, 3, 2] waits.</div><div class="line">Lock by:2 and [0, 1, 4, 3] waits.</div><div class="line">Lock by:3 and [2, 0, 1, 4] waits.</div><div class="line">Lock by:4 and [3, 2, 0, 1] waits.</div><div class="line">Lock by:1 and [4, 3, 2, 0] waits.</div><div class="line">Lock by:0 and [1, 4, 3, 2] waits.</div><div class="line">Lock by:2 and [0, 1, 4, 3] waits.</div><div class="line">Lock by:3 and [2, 0, 1, 4] waits.</div><div class="line">Lock by:4 and [3, 2, 0, 1] waits.</div><div class="line">Lock by:1 and [4, 3, 2, 0] waits.</div><div class="line">Lock by:0 and [4, 3, 2] waits.</div><div class="line">Lock by:2 and [4, 3] waits.</div><div class="line">Lock by:3 and [4] waits.</div><div class="line">Lock by:4 and [] waits.</div></pre></td></tr></table></figure>
</li>
<li></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">unfair version</div><div class="line">Lock by:0 and [] waits.</div><div class="line">Lock by:0 and [] waits.</div><div class="line">Lock by:0 and [1] waits.</div><div class="line">Lock by:2 and [1] waits.</div><div class="line">Lock by:2 and [3, 1] waits.</div><div class="line">Lock by:2 and [3, 1] waits.</div><div class="line">Lock by:2 and [0, 3, 1] waits.</div><div class="line">Lock by:2 and [0, 3, 1] waits.</div><div class="line">Lock by:1 and [0, 3] waits.</div><div class="line">Lock by:1 and [4, 0, 3] waits.</div><div class="line">Lock by:1 and [4, 0, 3] waits.</div><div class="line">Lock by:1 and [4, 0, 3] waits.</div><div class="line">Lock by:1 and [4, 0, 3] waits.</div><div class="line">Lock by:3 and [4, 0] waits.</div><div class="line">Lock by:3 and [4, 0] waits.</div><div class="line">Lock by:3 and [4, 0] waits.</div><div class="line">Lock by:3 and [4, 0] waits.</div><div class="line">Lock by:3 and [4, 0] waits.</div><div class="line">Lock by:0 and [4] waits.</div><div class="line">Lock by:0 and [4] waits.</div><div class="line">Lock by:4 and [] waits.</div><div class="line">Lock by:4 and [] waits.</div><div class="line">Lock by:4 and [] waits.</div><div class="line">Lock by:4 and [] waits.</div><div class="line">Lock by:4 and [] waits.</div></pre></td></tr></table></figure>
<h3 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h3><p>可以明显看出，在非公平获取的过程中，“插队”现象非常严重，后续获取锁的线程根本不顾及sync队列中等待的线程，而是能获取就获取。反观公平获取的过程，锁的获取就类似线性化的，每次都由sync队列中等待最长的线程（链表的第一个，sync队列是由尾部结点添加，当前输出的sync队列是逆序输出）获取锁。一个 hasQueuedPredecessors方法能够获得公平性的特性，这点实际上是由AbstractQueuedSynchronizer来完成的，看一下acquire方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public final void acquire(int arg) &#123;</div><div class="line">	if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">		selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，如果获取状态和在sync队列中排队是短路的判断，也就是说如果tryAcquire成功，那么是不会进入sync队列的，可以通过下图来深刻的认识公平性和AbstractQueuedSynchronizer的获取过程。<br>非公平的，或者说默认的获取方式如下图所示：</p>
<p>对于状态的获取，可以快速的通过tryAcquire的成功，也就是黄色的Fast路线，也可以由于tryAcquire的失败，构造节点，进入sync队列中排序后再次获取。因此可以理解为Fast就是一个快速通道，当例子中的线程释放锁之后，快速的通过Fast通道再次获取锁，就算当前sync队列中有排队等待的线程也会被忽略。这种模式，可以保证进入和退出锁的吞吐量，但是sync队列中过早排队的线程会一直处于阻塞状态，造成“饥饿”场景。</p>
<p><img src="http://ifeve.com/wp-content/uploads/2013/12/Untitled.png" alt=""></p>
<p>而公平性锁，就是在tryAcquire的调用中顾及当前sync队列中的等待节点（废弃了Fast通道），也就是任意请求都需要按照sync队列中既有的顺序进行，先到先得。这样很好的确保了公平性，但是可以从结果中看到，吞吐量就没有非公平的锁高了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/图解集合：ConcurrentHashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/图解集合：ConcurrentHashMap/" itemprop="url">图解集合：ConcurrentHashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T22:44:50+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码/" itemprop="url" rel="index">
                    <span itemprop="name">源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ConcurrentHashMap为什么高效？"><a href="#ConcurrentHashMap为什么高效？" class="headerlink" title="ConcurrentHashMap为什么高效？"></a>ConcurrentHashMap为什么高效？</h2><p>与Hashtable不同的是,ConcurrentHashMap使用的是<strong>分段锁技术</strong>,将ConcurrentHashMap容器的数据分段存储,每一段数据分配一个Segment,当线程占用一个Segment时,其他线程可以访问其他段的数据.</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><p>Segment : 可重入锁,继承ReentrantLock</p>
</li>
<li><p>HashEntry : 主要存储键值对,可以叫节点</p>
</li>
</ul>
<p><img src="http://7xjcjk.com1.z0.glb.clouddn.com/FtGrQxW5HJkkNelqtvhXWpV-hrHo" alt="image"></p>
<p>HashEntry结构:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">static final class HashEntry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;</div><div class="line">        // key值初始化后不能改变</div><div class="line">        final K key;</div><div class="line">        //volatile保证读到的数据为最新值</div><div class="line">        volatile V value;</div><div class="line">        //volatile保证读到的数据为最新的</div><div class="line">        volatile HashEntry&lt;K,V&gt; next;</div></pre></td></tr></table></figure>
<p>总结：</p>
<p>ConcurrentHashMap包含一个Segment数组,每个Segment包含一个HashEntry数组,当修改HashEntry数组采用开链法处理冲突,所以它的每个HashEntry元素又是链表结构的元素。</p>
<h2 id="基本操作源码分析"><a href="#基本操作源码分析" class="headerlink" title="基本操作源码分析"></a>基本操作源码分析</h2><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="HashEntry"><a href="#HashEntry" class="headerlink" title="HashEntry"></a>HashEntry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">//HashEntry类，作为一个Segment中的节点类。HashEntry类基本不可变。</div><div class="line">   static final class HashEntry&lt;K,V&gt; &#123;</div><div class="line">        final int hash;  //hash和key都是final，保证了读操作时不用加锁</div><div class="line">        final K key;</div><div class="line">        volatile V value;//为了确保读操作能够看到最新的值，将value设置成volatile</div><div class="line">        volatile HashEntry&lt;K,V&gt; next;</div><div class="line">        //不再用final关键字，采用unsafe操作保证并发安全</div><div class="line"></div><div class="line">        HashEntry(int hash, K key, V value, HashEntry&lt;K,V&gt; next) &#123;</div><div class="line">            this.hash = hash;</div><div class="line">            this.key = key;</div><div class="line">            this.value = value;</div><div class="line">            this.next = next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        //setNext方法可以设置该节点的next节点</div><div class="line">        final void setNext(HashEntry&lt;K,V&gt; n) &#123;</div><div class="line">            UNSAFE.putOrderedObject(this, nextOffset, n);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // Unsafe mechanics</div><div class="line">        static final sun.misc.Unsafe UNSAFE;</div><div class="line">        static final long nextOffset;</div><div class="line">        static &#123;</div><div class="line">            try &#123;</div><div class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</div><div class="line">                Class k = HashEntry.class;</div><div class="line">                nextOffset = UNSAFE.objectFieldOffset</div><div class="line">                    (k.getDeclaredField(&quot;next&quot;));</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                throw new Error(e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="Setment"><a href="#Setment" class="headerlink" title="Setment"></a>Setment</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div></pre></td><td class="code"><pre><div class="line">//Segment类</div><div class="line">static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable </div><div class="line">//继承ReentrantLock，说明每一个Segment都是一个锁</div><div class="line"></div><div class="line">    Segment(float lf, int threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</div><div class="line">        this.loadFactor = lf;</div><div class="line">        this.threshold = threshold;</div><div class="line">        //HashEntry的数组</div><div class="line">        this.table = tab;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 1.put方法，将一个HashEntry放入到该Segment中，使用自旋机制，减少了加锁的可能性</div><div class="line"></div><div class="line">   final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</div><div class="line">        HashEntry&lt;K,V&gt; node = tryLock() ? null :</div><div class="line">            scanAndLockForPut(key, hash, value); //如果加锁失败，则调用该方法</div><div class="line">        V oldValue;</div><div class="line">        try &#123;</div><div class="line">            HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">            int index = (tab.length - 1) &amp; hash; //同hashMap相同的哈希定位方式</div><div class="line">            HashEntry&lt;K,V&gt; first = entryAt(tab, index);</div><div class="line">            for (HashEntry&lt;K,V&gt; e = first;;) &#123;</div><div class="line">                if (e != null) &#123; </div><div class="line">            //若不为null，则持续查找，知道找到key和hash值相同的节点，将其value更新</div><div class="line">                    K k;</div><div class="line">                    if ((k = e.key) == key ||</div><div class="line">                        (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                        oldValue = e.value;</div><div class="line">                        if (!onlyIfAbsent) &#123;</div><div class="line">                            e.value = value;</div><div class="line">                            ++modCount;</div><div class="line">                        &#125;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                    e = e.next;</div><div class="line">                &#125;</div><div class="line">                else &#123; //若头结点为null</div><div class="line">                    if (node != null) //在遍历key对应节点链时没有找到相应的节点</div><div class="line">                        node.setNext(first);</div><div class="line">                        //当前修改并不需要让其他线程知道，在锁退出时修改自然会</div><div class="line">                        //更新到内存中,可提升性能</div><div class="line">                    else</div><div class="line">                        node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                    int c = count + 1;</div><div class="line">                    if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                        rehash(node); //如果超过阈值，则进行rehash操作</div><div class="line">                    else</div><div class="line">                        setEntryAt(tab, index, node);</div><div class="line">                    ++modCount;</div><div class="line">                    count = c;</div><div class="line">                    //没有值，返回null</div><div class="line">                    oldValue = null;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            unlock();</div><div class="line">        &#125;</div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">// 2.scanAndLockForPut方法，该操作持续查找key对应的节点链中是否已存在该节点，如果没有找到已存在的节点，则预创建一个新节点，并且尝试n次，直到尝试次数超出限制，才真正进入等待状态，即所谓的自旋等待。</div><div class="line"></div><div class="line">    private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123;</div><div class="line">        //根据hash值找到segment中的HashEntry节点</div><div class="line">        HashEntry&lt;K,V&gt; first = entryForHash(this, hash); //首先获取头结点</div><div class="line">        HashEntry&lt;K,V&gt; e = first;</div><div class="line">        HashEntry&lt;K,V&gt; node = null;</div><div class="line">        int retries = -1; // negative while locating node</div><div class="line">        while (!tryLock()) &#123;  //持续遍历该哈希链</div><div class="line">            HashEntry&lt;K,V&gt; f; // to recheck first below</div><div class="line">            if (retries &lt; 0) &#123;</div><div class="line">                if (e == null) &#123;</div><div class="line">                    if (node == null) //若不存在要插入的节点，则创建一个新的节点</div><div class="line">                        node = new HashEntry&lt;K,V&gt;(hash, key, value, null);</div><div class="line">                    retries = 0;</div><div class="line">                &#125;</div><div class="line">                else if (key.equals(e.key))</div><div class="line">                    retries = 0;</div><div class="line">                else</div><div class="line">                    e = e.next;</div><div class="line">            &#125;</div><div class="line">            else if (++retries &gt; MAX_SCAN_RETRIES) &#123; </div><div class="line">            //尝试次数超出限制，则进行自旋等待</div><div class="line">                lock();</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            /*当在自旋过程中发现节点链的链头发生了变化，则更新节点链的链头，</div><div class="line">            并重置retries值为－1，重新为尝试获取锁而自旋遍历*/</div><div class="line">            else if ((retries &amp; 1) == 0 &amp;&amp;</div><div class="line">                     (f = entryForHash(this, hash)) != first) &#123;</div><div class="line">                e = first = f; // re-traverse if entry changed</div><div class="line">                retries = -1;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return node;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// rehash方法，用于当容量超出阈值后，进行扩容操作，类似于hashMap的扩容操作</div><div class="line">    private void rehash(HashEntry&lt;K,V&gt; node) &#123;</div><div class="line">        HashEntry&lt;K,V&gt;[] oldTable = table;</div><div class="line">        int oldCapacity = oldTable.length;</div><div class="line">        int newCapacity = oldCapacity &lt;&lt; 1;</div><div class="line">        threshold = (int)(newCapacity * loadFactor);</div><div class="line">        HashEntry&lt;K,V&gt;[] newTable =</div><div class="line">            (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];</div><div class="line">        int sizeMask = newCapacity - 1;</div><div class="line">        for (int i = 0; i &lt; oldCapacity ; i++) &#123;</div><div class="line">            HashEntry&lt;K,V&gt; e = oldTable[i];</div><div class="line">            if (e != null) &#123;</div><div class="line">                HashEntry&lt;K,V&gt; next = e.next;</div><div class="line">                int idx = e.hash &amp; sizeMask;</div><div class="line">                if (next == null)   //  Single node on list</div><div class="line">                    newTable[idx] = e;</div><div class="line">                else &#123; // Reuse consecutive sequence at same slot</div><div class="line">                    HashEntry&lt;K,V&gt; lastRun = e;</div><div class="line">                    int lastIdx = idx;</div><div class="line">                    for (HashEntry&lt;K,V&gt; last = next;</div><div class="line">                         last != null;</div><div class="line">                         last = last.next) &#123;</div><div class="line">                        int k = last.hash &amp; sizeMask; //判断添加到哪个链表中去</div><div class="line">                        if (k != lastIdx) &#123;</div><div class="line">                            lastIdx = k;</div><div class="line">                            lastRun = last;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    newTable[lastIdx] = lastRun;</div><div class="line">                    // Clone remaining nodes</div><div class="line">                    for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</div><div class="line">                        V v = p.value;</div><div class="line">                        int h = p.hash;</div><div class="line">                        int k = h &amp; sizeMask;</div><div class="line">                        HashEntry&lt;K,V&gt; n = newTable[k];</div><div class="line">                        newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        int nodeIndex = node.hash &amp; sizeMask; // add the new node</div><div class="line">        node.setNext(newTable[nodeIndex]);</div><div class="line">        newTable[nodeIndex] = node;</div><div class="line">        table = newTable;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">// remove方法，用于移除某个节点，返回移除的节点值</div><div class="line">    final V remove(Object key, int hash, Object value) &#123;</div><div class="line">        if (!tryLock())</div><div class="line">            scanAndLock(key, hash);</div><div class="line">        V oldValue = null;</div><div class="line">        try &#123;</div><div class="line">            HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">            int index = (tab.length - 1) &amp; hash; </div><div class="line">            //根据这种哈希定位方式来定位对应的HashEntry</div><div class="line">            HashEntry&lt;K,V&gt; e = entryAt(tab, index); </div><div class="line">            HashEntry&lt;K,V&gt; pred = null;</div><div class="line">            while (e != null) &#123;</div><div class="line">                K k;</div><div class="line">                HashEntry&lt;K,V&gt; next = e.next;</div><div class="line">                if ((k = e.key) == key ||</div><div class="line">                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                    V v = e.value;</div><div class="line">                    if (value == null || value == v || value.equals(v)) &#123;</div><div class="line">                        if (pred == null)</div><div class="line">                            setEntryAt(tab, index, next);</div><div class="line">                        else</div><div class="line">                            pred.setNext(next);</div><div class="line">                        ++modCount;</div><div class="line">                        --count;</div><div class="line">                        oldValue = v;</div><div class="line">                    &#125;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">                pred = e;</div><div class="line">                e = next;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            unlock();</div><div class="line">        &#125;</div><div class="line">        return oldValue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">// clear方法，要首先对整个segment加锁，然后将每一个HashEntry都设置为null</div><div class="line">    final void clear() &#123;</div><div class="line">        lock();</div><div class="line">        try &#123;</div><div class="line">            HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">            for (int i = 0; i &lt; tab.length ; i++)</div><div class="line">                setEntryAt(tab, i, null);</div><div class="line">            ++modCount;</div><div class="line">            count = 0;</div><div class="line">        &#125; finally &#123;</div><div class="line">            unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public ConcurrentHashMap(int initialCapacity,</div><div class="line">                             float loadFactor, int concurrencyLevel) &#123;</div><div class="line">        //处理异常情况</div><div class="line">        if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</div><div class="line">            throw new IllegalArgumentException();</div><div class="line">        //判断并发级别是否大于最大并发级别（最大的并发等级不能超过MAX_SEGMENTS 1&lt;&lt;16(也就是1的二进制向左移16位,65536)）</div><div class="line">        if (concurrencyLevel &gt; MAX_SEGMENTS)</div><div class="line">            concurrencyLevel = MAX_SEGMENTS;</div><div class="line">        int sshift = 0;</div><div class="line">        int ssize = 1;</div><div class="line">        //取得大于数值最小的2的整数倍值</div><div class="line">        while (ssize &lt; concurrencyLevel) &#123;</div><div class="line">            ++sshift;</div><div class="line">            ssize &lt;&lt;= 1;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        //向左移动的位数</div><div class="line">        this.segmentShift = 32 - sshift;  //3定位segment</div><div class="line">        //达到最后取余的情况下（其余为正好全为11），正好是&amp;的结果</div><div class="line">        this.segmentMask = ssize - 1;   //4定位segment</div><div class="line">        if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">            initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">        //c代表平均每个元素的多少（不足时，全+1）</div><div class="line">        int c = initialCapacity / ssize;</div><div class="line">        if (c * ssize &lt; initialCapacity)</div><div class="line">            ++c;</div><div class="line">        //最小HashEntry表的数量</div><div class="line">        int cap = MIN_SEGMENT_TABLE_CAPACITY;</div><div class="line">        while (cap &lt; c)</div><div class="line">            cap &lt;&lt;= 1;</div><div class="line">        </div><div class="line">        //segment初始化</div><div class="line">        Segment&lt;K,V&gt; s0 =</div><div class="line">            new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),(HashEntry&lt;K,V&gt;[])new HashEntry[cap]);//初始化每个segment的长度</div><div class="line">        </div><div class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize]; //初始化segment数组</div><div class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); </div><div class="line">        this.segments = ss;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="查找数据操作"><a href="#查找数据操作" class="headerlink" title="查找数据操作"></a>查找数据操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public V get(Object key) &#123;</div><div class="line">        Segment&lt;K,V&gt; s; </div><div class="line">        HashEntry&lt;K,V&gt;[] tab;</div><div class="line">        //根据key的值计算hash值</div><div class="line">        int h = hash(key);</div><div class="line">        //获得segment的index</div><div class="line">        long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</div><div class="line">        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;  //通过hash值定位segment中对应的HashEntry 遍历HashEntry,如果key存在,返回key对应的value 如果不存在则返回null</div><div class="line">            (tab = s.table) != null) &#123;</div><div class="line">            for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</div><div class="line">                     (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</div><div class="line">                 e != null; e = e.next) &#123;</div><div class="line">                K k;</div><div class="line">                if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</div><div class="line">                    return e.value;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="插入数据操作"><a href="#插入数据操作" class="headerlink" title="插入数据操作"></a>插入数据操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">        Segment&lt;K,V&gt; s;</div><div class="line">        //键和值都不能为空</div><div class="line">        if (value == null)</div><div class="line">            throw new NullPointerException();</div><div class="line">        //计算key的hash值</div><div class="line">        int hash = hash(key);</div><div class="line">        //获得key所属的segemngt</div><div class="line">        int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</div><div class="line">        if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          </div><div class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null)</div><div class="line">            //初试化segment（懒加载模式）</div><div class="line">            s = ensureSegment(j);</div><div class="line">        return s.put(key, hash, value, false);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>segment的put方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;</div><div class="line">//获取锁，保证线程安全</div><div class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? null :</div><div class="line">                scanAndLockForPut(key, hash, value);</div><div class="line">            V oldValue;</div><div class="line">            try &#123;</div><div class="line">                HashEntry&lt;K,V&gt;[] tab = table;</div><div class="line">                </div><div class="line">                int index = (tab.length - 1) &amp; hash;</div><div class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);  //定位到具体的HashEntry</div><div class="line">                for (HashEntry&lt;K,V&gt; e = first;;) &#123; //3</div><div class="line">                    if (e != null) &#123;</div><div class="line">                        K k;</div><div class="line">                        if ((k = e.key) == key ||</div><div class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</div><div class="line">                            oldValue = e.value;</div><div class="line">                            //覆盖旧值</div><div class="line">                            if (!onlyIfAbsent) &#123;</div><div class="line">                                e.value = value;</div><div class="line">                                ++modCount;</div><div class="line">                            &#125;</div><div class="line">                            break;</div><div class="line">                        &#125;</div><div class="line">                        e = e.next;</div><div class="line">                    &#125;</div><div class="line">                    else &#123;</div><div class="line">                        if (node != null)</div><div class="line">                            node.setNext(first);</div><div class="line">                        else</div><div class="line">                            node = new HashEntry&lt;K,V&gt;(hash, key, value, first);</div><div class="line">                        int c = count + 1;</div><div class="line">                        if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</div><div class="line">                            rehash(node);</div><div class="line">                        else</div><div class="line">                            setEntryAt(tab, index, node);</div><div class="line">                        ++modCount;</div><div class="line">                        count = c;</div><div class="line">                        oldValue = null;</div><div class="line">                        break;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; finally &#123;</div><div class="line">            //释放锁</div><div class="line">                unlock();</div><div class="line">            &#125;</div><div class="line">            //返回旧值</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<h2 id="获取大小"><a href="#获取大小" class="headerlink" title="获取大小"></a>获取大小</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public int size() &#123;</div><div class="line">        final Segment&lt;K,V&gt;[] segments = this.segments;</div><div class="line">        int size;</div><div class="line">        boolean overflow; </div><div class="line">        long sum;         </div><div class="line">        long last = 0L;   </div><div class="line">        int retries = -1; </div><div class="line">        try &#123;</div><div class="line">            for (;;) &#123;</div><div class="line">            //RETRIES_BEFORE_LOCK为不变常量2 尝试两次不锁住Segment的方式来统计每个Segment的大小,如果在统计的过程中Segment的count发生变化,这时候再加锁统计Segment的count</div><div class="line">                if (retries++ == RETRIES_BEFORE_LOCK) &#123;  //加锁</div><div class="line">                    for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                        ensureSegment(j).lock(); </div><div class="line">                &#125;</div><div class="line">                sum = 0L;</div><div class="line">                size = 0;</div><div class="line">                overflow = false;</div><div class="line">                for (int j = 0; j &lt; segments.length; ++j) &#123;</div><div class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</div><div class="line">                    if (seg != null) &#123;</div><div class="line">                        sum += seg.modCount;  //2</div><div class="line">                        int c = seg.count;</div><div class="line">                        if (c &lt; 0 || (size += c) &lt; 0)</div><div class="line">                            overflow = true;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                if (sum == last)</div><div class="line">                    break;</div><div class="line">                last = sum;</div><div class="line">            &#125;</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (retries &gt; RETRIES_BEFORE_LOCK) &#123;</div><div class="line">                for (int j = 0; j &lt; segments.length; ++j)</div><div class="line">                    segmentAt(segments, j).unlock();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return overflow ? Integer.MAX_VALUE : size;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="弱一致性体现"><a href="#弱一致性体现" class="headerlink" title="弱一致性体现"></a>弱一致性体现</h1><p>get与containsKey两个方法几乎完全一致：他们都没有使用锁，而是通过Unsafe对象的getObjectVolatile()方法提供的原子读语义，来获得Segment以及对应的链表，然后对链表遍历判断是否存在key相同的节点以及获得该节点的value。但由于遍历过程中其他线程可能对链表结构做了调整，因此get和containsKey返回的可能是过时的数据，这一点是ConcurrentHashMap在弱一致性上的体现。如果要求强一致性，那么必须使用Collections.synchronizedMap()方法。</p>
<h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><ul>
<li>ConcurrentHashMap中的key和value值都不能为null，HashMap中key可以为null，HashTable中key不能为null。</li>
<li>ConcurrentHashMap是线程安全的类并不能保证使用了ConcurrentHashMap的操作都是线程安全的！</li>
<li>ConcurrentHashMap的get操作不需要加锁，put操作需要加锁 - put和get都只关心一个segment里面的hash操作质量也是很高的，如果hash后都存放在同一个segment中，那么使用这个类的意义就不会很大.</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/图解集合：HashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/图解集合：HashMap/" itemprop="url">图解集合：HashMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T16:02:51+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码/" itemprop="url" rel="index">
                    <span itemprop="name">源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="初识HashMap"><a href="#初识HashMap" class="headerlink" title="初识HashMap"></a>初识HashMap</h1><p>之前的List，讲了ArrayList、LinkedList，最后讲到CopyOnWriteArrayList，就前两者而言，反映的是两种思想：</p>
<ol>
<li>ArrayList以数组形式实现，顺序插入、查找快，插入、删除较慢</li>
<li>LinkedList以双向链表形式实现，顺序插入、查找较慢，插入、删除方便</li>
</ol>
<p>那么是否有一种数据结构能够结合上面两种的优点呢？有，答案就是HashMap。</p>
<p>HashMap是一种非常常见、方便和有用的集合，是一种键值对（K-V）形式的存储结构，下面将还是用图示的方式解读HashMap的实现原理。</p>
<h1 id="四个关注点在HashMap上的答案"><a href="#四个关注点在HashMap上的答案" class="headerlink" title="四个关注点在HashMap上的答案"></a>四个关注点在HashMap上的答案</h1><p><img src="http://img.blog.csdn.net/20170619205256171?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRfZHg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<h1 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h1><p>首先看一下HashMap的一个存储单元Entry：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</div><div class="line">    final K key;</div><div class="line">    V value;</div><div class="line">    Entry&lt;K,V&gt; next;</div><div class="line">    int hash;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之前一篇写LinkedList的文章，里面写到LinkedList是一个双向链表，从HashMap的Entry看得出，Entry组成的是一个单向链表，因为里面只有Entry的后继Entry，而没有Entry的前驱Entry。用图表示应该是这么一个数据结构：</p>
<p><img src="http://img.blog.csdn.net/20170619205358656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRfZHg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>接下来，假设我有这么一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args)</div><div class="line">&#123;</div><div class="line">     Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</div><div class="line">     map.put(&quot;111&quot;, &quot;111&quot;);</div><div class="line">     map.put(&quot;222&quot;, &quot;222&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下做了什么。首先从第3行开始，new了一个HashMap出来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public HashMap() &#123;</div><div class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">     threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</div><div class="line">     table = new Entry[DEFAULT_INITIAL_CAPACITY];</div><div class="line">     init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下第5行的init()是个空方法，它是HashMap的子类比如LinkedHashMap构造的时候使用的。loadFactor译为装载因子。装载因子用来衡量HashMap满的程度。loadFactor的默认值为0.75f。计算HashMap的实时装载因子的方法为元素的数量去除以capacity。DEFAULT_INITIAL_CAPACITY为16，也就是说，HashMap在new的时候构造出了一个大小为16的Entry数组，Entry内所有数据都取默认值，如图示为：</p>
<p><img src="http://img.blog.csdn.net/20170619205636003?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRfZHg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>看到new出了一个大小为16的Entry数组来。接着第4行，put了一个Key和Value同为111的字符串，看一下put的时候底层做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">    if (key == null)</div><div class="line">        return putForNullKey(value);</div><div class="line">    int hash = hash(key.hashCode());</div><div class="line">    int i = indexFor(hash, table.length);</div><div class="line">   //看是否存在相同的数据，当存在时，进行值覆盖</div><div class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</div><div class="line">       Object k;</div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(this);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">  //为了记录改变数据的操作的次数，在遍历Map时，会使用到modCount记录是否在遍历过程中是否modCount发生了改变。</div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    return null;</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int hash(int h) &#123;</div><div class="line">    // This function ensures that hashCodes that differ only by</div><div class="line">    // constant multiples at each bit position have a bounded</div><div class="line">    // number of collisions (approximately 8 at default load factor).</div><div class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</div><div class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static int indexFor(int h, int length) &#123;</div><div class="line">     return h &amp; (length-1);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看一下put方法的几个步骤：</p>
<ol>
<li>第2行~第3行就是HashMap允许Key值为空的原因，空的Key会默认放在第0位的数组位置上</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">private V putForNullKey(V value) &#123;</div><div class="line">//判断索引为0处的元素是否为空，若为空，则进行添加，若不为空，则对元素进行覆盖</div><div class="line">    for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123;</div><div class="line">        if (e.key == null) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            //为hashMap的子类提供，在hashMap中此方法为空</div><div class="line">            e.recordAccess(this);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    modCount++;</div><div class="line">    addEntry(0, null, value, 0);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>第4行拿到Key值的HashCode，由于HashCode是Object的方法，因此每个对象都有一个HashCode，对这个HashCode做一次hash计算。按照JDK源码注释的说法，这次hash的作用是根据给定的HashCode对它做一次打乱的操作，防止一些糟糕的Hash算法产生的糟糕的Hash值，至于为什么要防止糟糕的Hash值，HashMap添加元素的最后会讲到。</p>
</li>
<li><p>第5行根据重新计算的HashCode，对Entry数组的大小取模得到一个Entry数组的位置。看到这里使用了&amp;，移位加快一点代码运行效率。另外，这个取模操作的正确性依赖于length必须是2的N次幂，这个熟悉二进制的朋友一定理解，因此注意HashMap构造函数中，如果你指定HashMap初始数组的大小initialCapacity，如果initialCapacity不是2的N次幂，HashMap会算出大于initialCapacity的最小2的N次幂的值，作为Entry数组的初始化大小。这里为了讲解方便，我们假定字符串111和字符串222算出来的i都是1<br>这段代码保证初始化时 HashMap 的容量总是 2 的 n 次方，即底层数组的长度总是为 2 的 n 次方。当 length 总是 2 的 n 次方时，h&amp; (length-1)运算等价于对 length 取模，也就是 h%length，但是 &amp; 比 % 具有更高的效率。这看上去很简单，其实比较有玄机的，我们举个例子来说明：<br>假设数组长度分别为 15 和 16，优化后的 hash 码分别为 8 和 9，那么 &amp; 运算后的结果如下：</p>
</li>
</ol>
<p><img src="http://img.blog.csdn.net/20170619213553681?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRfZHg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>从上面的例子中可以看出：当它们和 15-1（1110）“与”的时候，产生了相同的结果，也就是说它们会定位到数组中的同一个位置上去，这就产生了碰撞，8 和 9 会被放到数组中的同一个位置上形成链表，那么查询的时候就需要遍历这个链表，得到8或者9，这样就降低了查询的效率。同时，我们也可以发现，当数组长度为 15 的时候，hash 值会与 15-1（1110）进行“与”，那么最后一位永远是 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！而当数组长度为16时，即为2的n次方时，2n-1 得到的二进制数的每个位上的值都为 1，这使得在低位上&amp;时，得到的和原 hash 的低位相同，加之 hash(int h)方法对 key 的 hashCode 的进一步优化，加入了高位计算，就使得只有相同的 hash 值的两个值才会被放到数组中的同一个位置上形成链表。</p>
<p>所以说，当数组长度为 2 的 n 次幂的时候，不同的 key 算得得 index 相同的几率较小，那么数据在数组上分布就比较均匀，也就是说碰撞的几率小，相对的，查询的时候就不用遍历某个位置上的链表，这样查询效率也就较高了。</p>
<ol>
<li><p>第6行~第14行会先判断一下原数据结构中是否存在相同的Key值，存在则覆盖并返回，不执行后面的代码。注意一下recordAccess这个方法，它也是HashMap的子类比如LinkedHashMap用的，HashMap中这个方法为空。另外，注意一点，对比Key是否相同，是先比HashCode是否相同，HashCode相同再判断equals是否为true，这样大大增加了HashMap的效率.</p>
</li>
<li><p>第16行的modeCount++是用于fail-fast机制的，每次修改HashMap数据结构的时候都会自增一次这个值</p>
</li>
</ol>
<p>然后就到了关键的addEntry方法了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">	Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">       table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">       //当超过阈值时，就进行扩容操作</div><div class="line">       if (size++ &gt;= threshold)</div><div class="line">           resize(2 * table.length);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>咱们再看一下Entry的构造方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;</div><div class="line">    value = v;</div><div class="line">    next = n;</div><div class="line">    key = k;</div><div class="line">    hash = h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假设new出来的Entry地址为0×00000001，那么，put(“111″, “111″)用图表示应该是这样的：<br><img src="http://img.blog.csdn.net/20170619214119617?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRfZHg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>每一个新增的Entry都位于table[1]上，另外，里面的hash是rehash之后的hash而不是Key最原始的hash。看到table[1]上存放了111—-&gt;111这个键值对，它持有原table[1]的引用地址，因此可以寻址到原table[1]，这就是单向链表。 再看一下put(“222″, “222″)做了什么，一张图就可以理解了：</p>
<p><img src="http://img.blog.csdn.net/20170619214154516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRfZHg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>新的Entry再次占据table[1]的位置，并且持有原table[1]，也就是111—-&gt;111这个键值对。<br>至此，HashMap进行put数据的过程就呈现清楚了。不过还有一个问题，就是HashMap如何进行扩容，再看一下addEntry方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">void addEntry(int hash, K key, V value, int bucketIndex) &#123;</div><div class="line">      Entry&lt;K,V&gt; e = table[bucketIndex];</div><div class="line">      table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">      if (size++ &gt;= threshold)</div><div class="line">          resize(2 * table.length);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>看到第4行~第5行，也就是说在每次放置完Entry之后都会判断是否需要扩容。</p>
<h1 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h1><p>有一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args)</div><div class="line">&#123;</div><div class="line">    Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();</div><div class="line">    map.put(&quot;111&quot;, &quot;111&quot;);</div><div class="line">    map.put(&quot;222&quot;, &quot;222&quot;);</div><div class="line">    map.remove(&quot;111&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第6行删除元素，看一下删除元素的时候做了什么，第4行~第5行添加了两个键值对就沿用上面的图，HashMap删除指定键值对的源代码是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public V remove(Object key) &#123;</div><div class="line">      Entry&lt;K,V&gt; e = removeEntryForKey(key);</div><div class="line">      //判断是否为空，若为空，则返回null，否则返回e.value</div><div class="line">      return (e == null ? null : e.value);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123;</div><div class="line">    //判断key值是否为null，若为空，则保存在索引为0的位置上</div><div class="line">    int hash = (key == null) ? 0 : hash(key.hashCode());</div><div class="line">    //求出对应的hash值在表中的索引位置</div><div class="line">    int i = indexFor(hash, table.length);</div><div class="line">    //将table[i]位置的链表取出来，进行修改</div><div class="line">    //prev表示上一个元素</div><div class="line">    Entry&lt;K,V&gt; prev = table[i];</div><div class="line">    //e表示当前值</div><div class="line">    Entry&lt;K,V&gt; e = prev;</div><div class="line">    while (e != null) &#123;</div><div class="line">        Entry&lt;K,V&gt; next = e.next;</div><div class="line">        Object k;</div><div class="line">        if (e.hash == hash &amp;&amp;</div><div class="line">            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123;</div><div class="line">            modCount++;</div><div class="line">            size--;</div><div class="line">            if (prev == e)</div><div class="line">                table[i] = next;</div><div class="line">            else</div><div class="line">                prev.next = next;</div><div class="line">            e.recordRemoval(this);</div><div class="line">            return e;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        prev = e;</div><div class="line">        e = next;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    return e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分析一下remove元素的时候做了几步：</p>
<p>1、根据key的hash找到待删除的键值对位于table的哪个位置上</p>
<p>2、记录一个prev表示待删除的Entry的前一个位置Entry，e可以认为是当前位置</p>
<p>3、从table[i]开始遍历链表，假如找到了匹配的Entry，要做一个判断，这个Entry是不是table[i]：</p>
<p>（1）是的话，也就是第14行~第15行，table[i]就直接是table[i]的下一个节点，后面的都不需要动</p>
<p>（2）不是的话，也就是第16行~第17行，e的前一个Entry也就是prev，prev的next指向e的后一个节点，也就是next，这样，e所代表的Entry就被踢出了，e的前后Entry就连起来了</p>
<p>remove(“111″)用图表示就是：</p>
<p><img src="http://img.blog.csdn.net/20170619220555159?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaXRfZHg=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>整个过程只需要修改一个节点的next的值即可，非常方便。</p>
<h1 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h1><p>修改元素也是put，看一下源代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public V put(K key, V value) &#123;</div><div class="line">//判断key值是否为空</div><div class="line">    if (key == null)</div><div class="line">        return putForNullKey(value);</div><div class="line">    int hash = hash(key.hashCode());</div><div class="line">    //求出元素所对应桶的位置</div><div class="line">    int i = indexFor(hash, table.length);</div><div class="line">    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;</div><div class="line">        Object k;</div><div class="line">        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</div><div class="line">            V oldValue = e.value;</div><div class="line">            e.value = value;</div><div class="line">            e.recordAccess(this);</div><div class="line">            return oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    modCount++;</div><div class="line">    addEntry(hash, key, value, i);</div><div class="line">    return null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个其实前面已经提到过了，第6行~第14行就是修改元素的逻辑，如果某个Key已经在数据结构中存在的话，那么就会覆盖原value，也就是第10行的代码。</p>
<h1 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h1><p>所谓”插入元素”，在我的理解里，一定是基于数据结构是有序的前提下的。像ArrayList、LinkedList，再远点说就是数据库，一条一条都是有序的。<br>而HashMap，它的顺序是基于HashCode，HashCode是一个随机性很强的数字，所以HashMap中的Entry完全是随机存放的。HashMap又不像LinkedHashMap这样维护了插入元素的顺序，所以对HashMap这个数据结构谈插入元素是没有意义的。<br>所以，HashMap并没有插入的概念。</p>
<h1 id="再谈HashCode的重要性"><a href="#再谈HashCode的重要性" class="headerlink" title="再谈HashCode的重要性"></a>再谈HashCode的重要性</h1><p>前面讲到了，HashMap中对Key的HashCode要做一次rehash，防止一些糟糕的Hash算法生成的糟糕的HashCode，那么为什么要防止糟糕HashCode？</p>
<p>糟糕的HashCode意味着的是Hash冲突，即多个不同的Key可能得到的是同一个HashCode，糟糕的Hash算法意味着的就是Hash冲突的概率增大，这意味着HashMap的性能将下降，表现在两方面：</p>
<p>1、有10个Key，可能6个Key的HashCode都相同，另外四个Key所在的Entry均匀分布在table的位置上，而某一个位置上却连接了6个Entry。这就失去了HashMap的意义，HashMap这种数据结构性高性能的前提是，Entry均匀地分布在table位置上，但现在确是1 1 1 1 6的分布。所以，我们要求HashCode有很强的随机性，这样就尽可能地可以保证了Entry分布的随机性，提升了HashMap的效率。</p>
<p>2、HashMap在一个某个table位置上遍历链表的时候的代码：</p>
<p>if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</p>
<p>看到，由于采用了”&amp;&amp;”运算符，因此先比较HashCode，HashCode都不相同就直接pass了，不会再进行equals比较了。HashCode因为是int值，比较速度非常快，而equals方法往往会对比一系列的内容，速度会慢一些。Hash冲突的概率大，意味着equals比较的次数势必增多，必然降低了HashMap的效率了。 </p>
<h1 id="HashMap的table为什么是transient的"><a href="#HashMap的table为什么是transient的" class="headerlink" title="HashMap的table为什么是transient的"></a>HashMap的table为什么是transient的</h1><p>一个非常细节的地方：</p>
<p>transient Entry[] table;</p>
<p>看到table用了transient修饰，也就是说table里面的内容全都不会被序列化，不知道大家有没有想过这么写的原因？</p>
<p>在我看来，这么写是非常必要的。因为HashMap是基于HashCode的，HashCode作为Object的方法，是native的：</p>
<p>public native int hashCode();</p>
<p>这意味着的是：HashCode和底层实现相关，不同的虚拟机可能有不同的HashCode算法。再进一步说得明白些就是，可能同一个Key在虚拟机A上的HashCode=1，在虚拟机B上的HashCode=2，在虚拟机C上的HashCode=3。</p>
<p>这就有问题了，Java自诞生以来，就以跨平台性作为最大卖点，好了，如果table不被transient修饰，在虚拟机A上可以用的程序到虚拟机B上可以用的程序就不能用了，失去了跨平台性，因为：</p>
<p>1、Key在虚拟机A上的HashCode=100，连在table[4]上</p>
<p>2、Key在虚拟机B上的HashCode=101，这样，就去table[5]上找Key，明显找不到</p>
<p>整个代码就出问题了。因此，为了避免这一点，Java采取了重写自己序列化table的方法，在writeObject选择将key和value追加到序列化的文件最后面：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">private void writeObject(java.io.ObjectOutputStream s)</div><div class="line">        throws IOException</div><div class="line">&#123;</div><div class="line">Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =</div><div class="line">    (size &gt; 0) ? entrySet0().iterator() : null;</div><div class="line"> </div><div class="line">// Write out the threshold, loadfactor, and any hidden stuff</div><div class="line">s.defaultWriteObject();</div><div class="line"> </div><div class="line">// Write out number of buckets</div><div class="line">s.writeInt(table.length);</div><div class="line"> </div><div class="line">// Write out size (number of Mappings)</div><div class="line">s.writeInt(size);</div><div class="line"> </div><div class="line">    // Write out keys and values (alternating)</div><div class="line">if (i != null) &#123;</div><div class="line"> while (i.hasNext()) &#123;</div><div class="line">    Map.Entry&lt;K,V&gt; e = i.next();</div><div class="line">    s.writeObject(e.getKey());</div><div class="line">    s.writeObject(e.getValue());</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而在readObject的时候重构HashMap数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">private void readObject(java.io.ObjectInputStream s)</div><div class="line">         throws IOException, ClassNotFoundException</div><div class="line">&#123;</div><div class="line">// Read in the threshold, loadfactor, and any hidden stuff</div><div class="line">s.defaultReadObject();</div><div class="line"> </div><div class="line">// Read in number of buckets and allocate the bucket array;</div><div class="line">int numBuckets = s.readInt();</div><div class="line">table = new Entry[numBuckets];</div><div class="line"> </div><div class="line">    init();  // Give subclass a chance to do its thing.</div><div class="line"> </div><div class="line">// Read in size (number of Mappings)</div><div class="line">int size = s.readInt();</div><div class="line"> </div><div class="line">// Read the keys and values, and put the mappings in the HashMap</div><div class="line">for (int i=0; i&lt;size; i++) &#123;</div><div class="line">    K key = (K) s.readObject();</div><div class="line">    V value = (V) s.readObject();</div><div class="line">    putForCreate(key, value);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一种麻烦的方式，但却保证了跨平台性。</p>
<p>这个例子也告诉了我们：尽管使用的虚拟机大多数情况下都是HotSpot，但是也不能对其它虚拟机不管不顾，有跨平台的思想是一件好事。</p>
<h1 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h1><p>HashMap和Hashtable是一组相似的键值对集合，它们的区别也是面试常被问的问题之一，我这里简单总结一下HashMap和Hashtable的区别：</p>
<p>1、Hashtable是线程安全的，Hashtable所有对外提供的方法都使用了synchronized，也就是同步，而HashMap则是线程非安全的</p>
<p>2、Hashtable不允许空的value，空的value将导致空指针异常，而HashMap则无所谓，没有这方面的限制</p>
<p>3、上面两个缺点是最主要的区别，另外一个区别无关紧要，我只是提一下，就是两个的rehash算法不同，Hashtable的是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">private int hash(Object k) &#123;</div><div class="line">    // hashSeed will be zero if alternative hashing is disabled.</div><div class="line">    return hashSeed ^ k.hashCode();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个hashSeed是使用sun.misc.Hashing类的randomHashSeed方法产生的。HashMap的rehash算法上面看过了，也就是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">static int hash(int h) &#123;</div><div class="line">    // This function ensures that hashCodes that differ only by</div><div class="line">    // constant multiples at each bit position have a bounded</div><div class="line">    // number of collisions (approximately 8 at default load factor).</div><div class="line">    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);</div><div class="line">    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/并发情况下HashMap出现死循环情况解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="NobiGo">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/雄.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="NobiGo's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/并发情况下HashMap出现死循环情况解析/" itemprop="url">并发情况下HashMap出现死循环情况解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T14:58:09+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码/" itemprop="url" rel="index">
                    <span itemprop="name">源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="并发情况下HashMap出现死循环情况解析"><a href="#并发情况下HashMap出现死循环情况解析" class="headerlink" title="并发情况下HashMap出现死循环情况解析"></a>并发情况下HashMap出现死循环情况解析</h1><h2 id="现象发生"><a href="#现象发生" class="headerlink" title="现象发生"></a>现象发生</h2><p>由于偶尔会遇到HashMap死循环造成CPU100%，重启后问题消失，隔一段时间又会反复出现。今天在这里来仔细剖析下多线程情况下HashMap所带来的问题：</p>
<h2 id="多线程put操作后，get操作导致死循环。"><a href="#多线程put操作后，get操作导致死循环。" class="headerlink" title="多线程put操作后，get操作导致死循环。"></a>多线程put操作后，get操作导致死循环。</h2><h3 id="死循环场景重现"><a href="#死循环场景重现" class="headerlink" title="死循环场景重现"></a>死循环场景重现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Test extends Thread</div><div class="line">&#123;</div><div class="line">    static HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(2);</div><div class="line">    static AtomicInteger at = new AtomicInteger();</div><div class="line">    </div><div class="line">    public void run()</div><div class="line">    &#123;</div><div class="line">        while(at.get() &lt; 100000)</div><div class="line">        &#123;</div><div class="line">            map.put(at.get(),at.get());</div><div class="line">            at.incrementAndGet();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">package dx.hashmap.com;</div><div class="line"></div><div class="line">public class Main &#123;</div><div class="line">    public static void main(String[] args)</div><div class="line">    &#123;</div><div class="line">        Test t0 = new Test();</div><div class="line">        Test t1 = new Test();</div><div class="line">        Test t2 = new Test();</div><div class="line">        Test t3 = new Test();</div><div class="line">        Test t4 = new Test();</div><div class="line">        t0.start();</div><div class="line">        t1.start();</div><div class="line">        t2.start();</div><div class="line">        t3.start();</div><div class="line">        t4.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>反复执行几次，出现这种情况则表示死循环了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&quot;Thread-0&quot; prio=5 tid=0x00007ffec50f5800 nid=0x4b03 runnable [0x0000700001c8f000]</div><div class="line">   java.lang.Thread.State: RUNNABLE</div><div class="line">        at java.util.HashMap.transfer(HashMap.java:601)</div><div class="line">        at java.util.HashMap.resize(HashMap.java:581)</div><div class="line">        at java.util.HashMap.addEntry(HashMap.java:879)</div><div class="line">        at java.util.HashMap.put(HashMap.java:505)</div><div class="line">        at dx.hashmap.com.Test.run(Test.java:13)</div><div class="line"></div><div class="line">&quot;Service Thread&quot; daemon prio=5 tid=0x00007ffec5022000 nid=0x4703 runnable [0x0000000000000000]</div><div class="line">   java.lang.Thread.State: RUNNABLE</div></pre></td></tr></table></figure>
<p>通过堆栈可以看到：Thread-0由于HashMap的扩容操作导致了死循环。</p>
<h3 id="正常的扩容过程"><a href="#正常的扩容过程" class="headerlink" title="正常的扩容过程"></a>正常的扩容过程</h3><p>我们先来看下单线程情况下，正常的rehash过程</p>
<ul>
<li><p>1.假设我们的hash算法是简单的key mod一下表的大小（即数组的长度）。</p>
</li>
<li><p>2.最上面是old hash表，其中HASH表的size=2，所以key=3,5,7在mod 2 以后都冲突在table[1]这个位置上了。</p>
</li>
<li><p>3.接下来HASH表扩容，resize=4，然后所有的<key,value>重新进行散列分布，过程如下：</key,value></p>
</li>
</ul>
<p><img src="http://images2015.cnblogs.com/blog/831179/201606/831179-20160620074305522-158439805.png" alt=""></p>
<p>在单线程情况下，一切看起来都很美妙，扩容过程也相当顺利。接下来看下并发情况下的扩容。</p>
<h3 id="并发情况下的扩容"><a href="#并发情况下的扩容" class="headerlink" title="并发情况下的扩容"></a>并发情况下的扩容</h3><ul>
<li><p>1.首先假设我们有两个线程，分别用红色和蓝色标注了。</p>
</li>
<li><p>2.扩容部分的源代码：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">     * Transfers all entries from current table to newTable.</div><div class="line">     */</div><div class="line">    void transfer(Entry[] newTable, boolean rehash) &#123;</div><div class="line">        int newCapacity = newTable.length;</div><div class="line">        for (Entry&lt;K,V&gt; e : table) &#123;</div><div class="line">            while(null != e) &#123;</div><div class="line">                Entry&lt;K,V&gt; next = e.next;</div><div class="line">                if (rehash) &#123;</div><div class="line">                    e.hash = null == e.key ? 0 : hash(e.key);</div><div class="line">                &#125;</div><div class="line">                int i = indexFor(e.hash, newCapacity);</div><div class="line">                e.next = newTable[i];</div><div class="line">                newTable[i] = e;</div><div class="line">                e = next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<ul>
<li>3.如果在线程一执行到Entry<k,v> next = e.next<br>代码就被CPU调度挂起，去执行线程2，且线程2把上面代码都执行完毕。我们来看看这个时候的状态：</k,v></li>
</ul>
<p><img src="http://images2015.cnblogs.com/blog/831179/201606/831179-20160620074911319-1507561812.png" alt=""></p>
<ul>
<li>4.接着CPU切换到线程一上来，继续执行代码，首先安置3这个Entry：</li>
</ul>
<p><img src="http://images2015.cnblogs.com/blog/831179/201606/831179-20160620215401225-1774760096.png" alt=""></p>
<p>这里需要注意的是：线程二已经完成执行完成，现在table里面所有的Entry都是最新的，就是说7的next是3,3的next是null；现在第一次循环已经结束，3已经安置妥当。看看接下来会发生什么事情：</p>
<ul>
<li><p>1.e=next=7</p>
</li>
<li><p>2.e!=null,循环继续</p>
</li>
<li><p>3.next=e.next=3</p>
</li>
<li><p>4.e.next 7的next指向3</p>
</li>
<li><p>5.放置7这个Entry，现在如图所示：</p>
</li>
</ul>
<p><img src="http://images2015.cnblogs.com/blog/831179/201606/831179-20160620220528615-1921197618.png" alt=""></p>
<p>放置7之后，接着运行代码：</p>
<ul>
<li><ol>
<li>e=next=3;</li>
</ol>
</li>
<li><ol>
<li>判断不为空，继续循环</li>
</ol>
</li>
<li><ol>
<li>next= e.next  这里也就是3的next 为null</li>
</ol>
</li>
<li><ol>
<li>e.next=7,就3的next指向7.</li>
</ol>
</li>
<li><ol>
<li>放置3这个Entry，此时的状态如图： </li>
</ol>
</li>
</ul>
<p><img src="http://images2015.cnblogs.com/blog/831179/201606/831179-20160620220921022-137089907.png" alt=""></p>
<p>这个时候其实就出现了死循环了，3移动节点头的位置，指向7这个Entry;在这之前7的next同时也指向了3这个Entry。</p>
<p>代码接着往下执行，e=next=null，此时条件判断会终止循环。这次扩容结束了。但是后续如果有查询（无论是查询的迭代还是扩容），都会hang死在table【3】这个位置上。现在回过来看文章开头的那个Demo，就是挂死在扩容阶段的transfer这个方法上面。</p>
<p><strong>出现上面这种情况绝不是我要在测试环境弄一批数据专门为了演示这种问题。我们仔细思考一下就会得出这样一个结论：如果扩容前相邻的两个Entry在扩容后还是分配到相同的table位置上，就会出现死循环的BUG。在复杂的生产环境中，这种情况尽管不常见，但是可能会碰到。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="/images/雄.png"
              alt="NobiGo" />
          
            <p class="site-author-name" itemprop="name">NobiGo</p>
            <p class="site-description motion-element" itemprop="description">愿你出走半生，归来依旧少年</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">NobiGo</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
